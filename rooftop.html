<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rooftop Quiet Time</title>
  <style>
    :root{
      --bg1:#0b1c2d;
      --bg2:#162a3d;
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.55);
      --stroke: rgba(255,255,255,0.12);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Inter,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 800px at 50% -10%, rgba(255,255,255,0.08), transparent 55%),
                  linear-gradient(180deg,var(--bg1),var(--bg2));
      color: var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding: 18px 14px 28px;
    }
    .wrap{ width:min(820px, 100%); }
    h1{
      margin: 6px 0 6px;
      text-align:center;
      font-size: 40px;
      letter-spacing:-0.5px;
      line-height:1.05;
      font-weight: 900;
      text-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .sub{
      text-align:center;
      color: var(--muted);
      font-size: 15px;
      margin-bottom: 14px;
    }

    .gameCard{
      width:100%;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      padding: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.08);
      display:block;
      touch-action: manipulation;
    }

    .panel{
      margin-top: 14px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 14px;
      box-shadow: 0 18px 44px rgba(0,0,0,0.25);
    }
    .typeBox{
      white-space: pre-wrap;
      font-size: 14px;
      line-height: 1.45;
      color: rgba(255,255,255,0.90);
      min-height: 150px;
    }

    .controls{
      margin-top: 12px;
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      justify-content:center;
    }
    .btn{
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.95);
      font-weight: 800;
      font-size: 15px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      min-width: 150px;
      text-align:center;
    }
    .btn:active{ transform: translateY(1px); }
    .btn[disabled]{
      opacity: 0.45;
      cursor: not-allowed;
    }
    .hint{
      margin-top: 10px;
      text-align:center;
      color: var(--muted2);
      font-size: 13px;
    }

    /* Modal */
    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: linear-gradient(180deg, rgba(0,0,0,0.30), rgba(0,0,0,0.72));
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(520px, 96%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(20,30,45,0.88);
      box-shadow: 0 22px 70px rgba(0,0,0,0.5);
      padding: 16px;
    }
    .modal h2{
      margin: 0 0 8px;
      font-size: 18px;
      font-weight: 900;
      text-align:center;
    }
    .modal p{
      margin: 0 0 12px;
      color: rgba(255,255,255,0.78);
      font-size: 13px;
      line-height:1.35;
      text-align:center;
    }
    .modal .row{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      justify-content:center;
      margin-top: 10px;
    }
    .small{
      font-size: 12px;
      color: rgba(255,255,255,0.65);
      text-align:center;
      margin-top: 10px;
    }
    a.dl{
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      text-decoration: underline;
    }

    /* Surprise button */
    .surpriseBtn{
      display:none;
      margin: 14px auto 0;
      width: min(520px, 96%);
      padding: 16px 18px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.95);
      font-weight: 900;
      font-size: 17px;
      text-align:center;
      box-shadow: 0 18px 48px rgba(0,0,0,0.35);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    @media (max-width: 420px){
      h1{ font-size: 34px; }
      .btn{ min-width: 140px; }
      .typeBox{ min-height: 165px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Rooftop Quiet Time ðŸŒ™</h1>
    <div class="sub">A calm moment â€” record your reflection, then come back for a mini surprise.</div>

    <div class="gameCard">
      <canvas id="scene" width="800" height="520"></canvas>

      <div id="shareOverlay" class="overlay">
        <div class="modal">
          <h2>Send your audio to Sandra</h2>
          <p>Tap <b>Share</b> to open your share sheet and choose Telegram.<br/>Message is prefilled + audio attached.</p>
          <div class="row">
            <div class="btn" id="shareBtn">Share</div>
            <div class="btn" id="closeShare">Close</div>
          </div>
          <div class="small">
            If Telegram doesnâ€™t attach the file on your device, use:
            <br/>
            <a id="downloadLink" class="dl" href="#" download>Download audio</a>
            <br/>then send it in Telegram manually.
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div id="typeBox" class="typeBox"></div>

      <div class="controls">
        <button class="btn" id="recordBtn">Record</button>
        <button class="btn" id="stopBtn" disabled>Stop</button>
        <button class="btn" id="sendBtn" disabled>Send to Sandra</button>
      </div>

      <div class="hint" id="statusHint">Tip: record in one go (one recording only).</div>

      <div id="surpriseBtn" class="surpriseBtn">Click for a mini surprise!</div>
    </div>
  </div>

  <script>
    // =========================
    // Rooftop Quiet Time (single-file)
    // - Static skyline (no movement)
    // - One recording only
    // - Share audio file + prefilled text
    // - Return -> 2.5s -> surprise button
    // - Surprise: sljy14 walks in, gives flowers (ends next to agy96), fireworks loop, plays bday.mp3
    // =========================

    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    const typeBox = document.getElementById("typeBox");
    const recordBtn = document.getElementById("recordBtn");
    const stopBtn = document.getElementById("stopBtn");
    const sendBtn = document.getElementById("sendBtn");
    const statusHint = document.getElementById("statusHint");

    const shareOverlay = document.getElementById("shareOverlay");
    const shareBtn = document.getElementById("shareBtn");
    const closeShare = document.getElementById("closeShare");
    const downloadLink = document.getElementById("downloadLink");

    const surpriseBtn = document.getElementById("surpriseBtn");

    // ---------- Typewriter instructions ----------
    const fullText =
`Follow these instructions carefully.

1. Think about these two questions:
A. Now that youâ€™ve turned 30, what would you tell your 21-year-old self?
B. What is your 30-year-old birthday wish for yourself?

2. Click on Record to start recording your answers
3. Click on â€œSend to Sandraâ€
4. A pop up will appear â€” send it to Sandra through Telegram
5. !Important! Come back to this screen for a mini surprise`;

    function typeWriter(text, el, speed=14){
      el.textContent = "";
      let i = 0;
      const timer = setInterval(() => {
        el.textContent += text[i] ?? "";
        i++;
        if (i >= text.length) clearInterval(timer);
      }, speed);
    }
    typeWriter(fullText, typeBox);

    // ---------- Recording (robust mobile) ----------
    let mediaStream = null;
    let recorder = null;
    let chunks = [];
    let audioBlob = null;
    let audioFile = null;
    let didSendFlow = false; // set true when user taps "Send to Sandra"
    let hasRecordedOnce = false; // one recording only

    function pickMimeType(){
      // Prefer iOS-friendly first if supported
      const candidates = [
        "audio/mp4;codecs=mp4a.40.2",
        "audio/mp4",
        "audio/webm;codecs=opus",
        "audio/webm"
      ];
      for (const t of candidates){
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
      }
      return ""; // let browser decide
    }

    async function startRecording(){
      if (hasRecordedOnce) return;

      statusHint.textContent = "Requesting microphoneâ€¦";
      chunks = [];
      audioBlob = null;
      audioFile = null;

      try{
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const mimeType = pickMimeType();
        recorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : undefined);

        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        recorder.onstop = () => {
          const finalType = recorder.mimeType || (chunks[0] && chunks[0].type) || "audio/webm";
          audioBlob = new Blob(chunks, { type: finalType });

          // Choose extension based on type
          const ext = finalType.includes("mp4") ? "m4a" : "webm";
          audioFile = new File([audioBlob], `agy96_rooftop_reflection.${ext}`, { type: finalType });

          // Enable send
          sendBtn.disabled = false;

          // One recording only (lock Record)
          hasRecordedOnce = true;
          recordBtn.disabled = true;

          // Provide download fallback
          const url = URL.createObjectURL(audioBlob);
          downloadLink.href = url;

          statusHint.textContent = "Recording saved. Tap â€œSend to Sandraâ€.";
        };

        recorder.start();
        recordBtn.disabled = true;
        stopBtn.disabled = false;
        sendBtn.disabled = true;
        statusHint.textContent = "Recordingâ€¦ speak your answers (one take).";

      } catch(err){
        console.error(err);
        statusHint.textContent = "Mic blocked. Please allow microphone access and try again.";
      }
    }

    function stopRecording(){
      if (!recorder) return;
      stopBtn.disabled = true;
      statusHint.textContent = "Finalizing audioâ€¦";
      recorder.stop();

      // stop tracks
      if (mediaStream){
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
    }

    recordBtn.addEventListener("click", startRecording);
    stopBtn.addEventListener("click", stopRecording);

    // ---------- Share flow ----------
    const PREFILLED_TEXT = "hereâ€™s my 30th rooftop reflection ðŸ¥¹";

    function openShareModal(){
      if (!audioFile){
        statusHint.textContent = "Please record first.";
        return;
      }
      didSendFlow = true;
      shareOverlay.classList.add("show");
    }

    closeShare.addEventListener("click", () => {
      shareOverlay.classList.remove("show");
      statusHint.textContent = "After you share in Telegram, come back to this tab for a mini surprise ðŸ™‚";
    });

    async function doShare(){
      if (!audioFile) return;

      // navigator.share with files works on most modern iOS/Android browsers, but Telegram behavior can vary.
      if (navigator.share && navigator.canShare && navigator.canShare({ files: [audioFile] })){
        try{
          await navigator.share({
            files: [audioFile],
            text: PREFILLED_TEXT,
            title: "Rooftop Reflection"
          });
          shareOverlay.classList.remove("show");
          statusHint.textContent = "Sent? Come back to this screen for your mini surprise ðŸ™‚";
        } catch(e){
          // user cancelled is normal
          console.log("Share cancelled or failed:", e);
          statusHint.textContent = "If share didnâ€™t work, download the audio and send manually in Telegram.";
        }
      } else {
        // Fallback: download link + copy text
        statusHint.textContent = "Your browser canâ€™t attach files via share sheet. Download the audio, then send it on Telegram.";
      }
    }

    shareBtn.addEventListener("click", doShare);
    sendBtn.addEventListener("click", openShareModal);

    // ---------- Surprise trigger after returning ----------
    let pendingSurpriseTimer = null;

    function scheduleSurpriseButton(){
      if (!didSendFlow) return;
      if (pendingSurpriseTimer) clearTimeout(pendingSurpriseTimer);

      pendingSurpriseTimer = setTimeout(() => {
        surpriseBtn.style.display = "block";
      }, 2500);
    }

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) scheduleSurpriseButton();
    });
    window.addEventListener("focus", scheduleSurpriseButton);

    // ---------- Scene: static rooftop + characters ----------
    const agy = {
      x: 250, y: 410,
      label: "agy96"
    };

    const sljy = {
      x: 880, y: 410,
      targetX: 360,
      label: "sljy14",
      walking: false
    };

    const bouquet = {
      x: 0, y: 0,
      state: "hidden", // hidden | carried | placed
      placedX: 290,
      placedY: 386
    };

    let fireworksOn = false;
    let surpriseStarted = false;

    // Audio (plays on user gesture => reliable on iOS/Android)
    const bdayAudio = new Audio("bday.mp3");
    bdayAudio.preload = "auto";

    // Stars
    const stars = Array.from({length: 150}).map(() => ({
      x: Math.random()*canvas.width,
      y: Math.random()*250,
      a: 0.35 + Math.random()*0.65,
      r: 0.6 + Math.random()*1.6
    }));

    // Fireworks particles
    let sparks = [];
    function spawnFirework(){
      const cx = 120 + Math.random()*(canvas.width-240);
      const cy = 90 + Math.random()*140;
      const n = 28;
      for (let i=0;i<n;i++){
        const ang = (Math.PI*2)*(i/n) + Math.random()*0.2;
        const spd = 1.6 + Math.random()*2.4;
        sparks.push({
          x: cx, y: cy,
          vx: Math.cos(ang)*spd,
          vy: Math.sin(ang)*spd,
          life: 1400 + Math.random()*600
        });
      }
    }

    function updateFireworks(dt){
      // spawn periodically
      if (fireworksOn){
        if (Math.random() < 0.03) spawnFirework();
      }

      for (const p of sparks){
        p.life -= dt;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.0025 * dt; // gentle gravity
        p.vx *= 0.995;
        p.vy *= 0.995;
      }
      sparks = sparks.filter(p => p.life > 0);
    }

    function drawFireworks(){
      ctx.save();
      for (const p of sparks){
        const a = Math.max(0, Math.min(1, p.life/1800));
        ctx.fillStyle = `rgba(255,255,255,${0.15 + 0.65*a})`;
        ctx.fillRect(p.x, p.y, 2, 2);
      }
      ctx.restore();
    }

    // ---------- Draw helpers ----------
    function drawBackground(){
      // Sky
      const g = ctx.createLinearGradient(0,0,0,canvas.height);
      g.addColorStop(0,"#061425");
      g.addColorStop(1,"#0c2540");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Stars (static positions, subtle twinkle)
      const t = performance.now();
      for (const s of stars){
        const tw = 0.85 + 0.15*Math.sin(t/1400 + s.x*0.02);
        ctx.fillStyle = `rgba(255,255,255,${s.a*tw})`;
        ctx.fillRect(s.x, s.y, s.r, s.r);
      }

      // Moon (crescent)
      ctx.save();
      ctx.translate(690, 110);
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.beginPath();
      ctx.arc(0,0,26,0,Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(8,0,24,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
      ctx.globalCompositeOperation = "source-over";

      // Skyline (STATIC)
      drawSkyline();

      // Rooftop floor
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0, 345, canvas.width, 175);

      // Rail
      ctx.fillStyle = "rgba(255,255,255,0.14)";
      ctx.fillRect(80, 332, 640, 8);
      ctx.strokeStyle = "rgba(255,255,255,0.16)";
      ctx.lineWidth = 2;
      ctx.strokeRect(80, 332, 640, 70);

      // small floor speckles
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      for (let i=0;i<40;i++){
        const x = (i*19) % canvas.width;
        const y = 360 + ((i*37) % 150);
        ctx.fillRect(x, y, 2, 1);
      }
    }

    function drawSkyline(){
      // layered buildings (static bars)
      const layers = [
        {y:110, h:220, c:"rgba(40,90,160,0.55)"},
        {y:120, h:230, c:"rgba(32,74,138,0.65)"},
        {y:135, h:250, c:"rgba(26,60,120,0.75)"}
      ];
      for (const L of layers){
        ctx.fillStyle = L.c;
        let x = 0;
        while (x < canvas.width){
          const w = 18 + Math.random()*44;
          const hh = 60 + Math.random()*L.h;
          ctx.fillRect(x, L.y + (240 - hh), w, hh);
          x += w + 6 + Math.random()*10;
        }
      }
      // horizon band
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(0, 285, canvas.width, 4);
    }

    function drawFurniture(){
      // Couch / bed platform (left)
      ctx.fillStyle = "#6b5f1a";
      ctx.fillRect(150, 390, 250, 90);

      // Coffee table (center)
      ctx.fillStyle = "#b6ad9f";
      ctx.fillRect(430, 440, 120, 55);

      // Plant (right)
      ctx.fillStyle = "#c7b07a";
      ctx.fillRect(640, 430, 70, 80);
      ctx.fillStyle = "#1da24f";
      ctx.fillRect(655, 400, 40, 40);
    }

    function drawLabel(text, x, y){
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(text, x, y);
    }

    // agy96 sprite sitting (even legs)
    function drawAgySitting(px, py){
      ctx.save();
      ctx.translate(px, py);

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.beginPath();
      ctx.ellipse(0, 46, 36, 10, 0, 0, Math.PI*2);
      ctx.fill();

      drawLabel("agy96", 0, -10);

      // hair block (thicker sides)
      ctx.fillStyle = "#0a0a0a";
      ctx.fillRect(-20, -62, 40, 34);
      ctx.fillRect(-22, -58, 4, 30);
      ctx.fillRect(18,  -58, 4, 30);
      ctx.fillRect(-20, -28, 40, 8);

      // face
      ctx.fillStyle = "#f1c9a8";
      ctx.fillRect(-14, -50, 28, 22);

      // glasses
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(-12, -46, 10, 8);
      ctx.strokeRect(2, -46, 10, 8);
      ctx.beginPath();
      ctx.moveTo(-2, -42);
      ctx.lineTo(2, -42);
      ctx.stroke();

      // torso
      ctx.fillStyle = "#c43737";
      ctx.fillRect(-16, -28, 32, 22);

      // legs (even, sitting forward)
      ctx.fillStyle = "#1f2530";
      ctx.fillRect(-16, -6, 32, 14);

      // shoes (even)
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-18, 8, 16, 8);
      ctx.fillRect(2,  8, 16, 8);

      // arms
      ctx.fillStyle = "#f1c9a8";
      ctx.fillRect(-20, -24, 4, 16);
      ctx.fillRect(16, -24, 4, 16);

      ctx.restore();
    }

    // sljy14 sprite (black tee + black mini skirt)
    function drawSljy(px, py){
      ctx.save();
      ctx.translate(px, py);

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.28)";
      ctx.beginPath();
      ctx.ellipse(0, 46, 34, 10, 0, 0, Math.PI*2);
      ctx.fill();

      drawLabel("sljy14", 0, -10);

      // hair
      ctx.fillStyle = "#2b1d12";
      ctx.fillRect(-18, -62, 36, 24);

      // face
      ctx.fillStyle = "#eab48f";
      ctx.fillRect(-12, -50, 24, 20);

      // shirt (black tee)
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(-16, -30, 32, 22);

      // mini skirt (black)
      ctx.fillStyle = "#0f0f0f";
      ctx.fillRect(-14, -8, 28, 14);

      // legs
      ctx.fillStyle = "#eab48f";
      ctx.fillRect(-10, 6, 8, 16);
      ctx.fillRect(2,  6, 8, 16);

      // shoes
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-12, 22, 10, 8);
      ctx.fillRect(2,  22, 10, 8);

      // arms
      ctx.fillStyle = "#eab48f";
      ctx.fillRect(-20, -26, 4, 18);
      ctx.fillRect(16,  -26, 4, 18);

      ctx.restore();
    }

    function drawBouquet(x, y){
      ctx.save();
      ctx.translate(x, y);

      // pot wrap
      ctx.fillStyle = "#d9d0c0";
      ctx.fillRect(-10, 10, 20, 14);

      // stems
      ctx.fillStyle = "#1da24f";
      ctx.fillRect(-2, 0, 4, 12);

      // flowers
      ctx.fillStyle = "#ff8fb3";
      ctx.fillRect(-10, -2, 6, 6);
      ctx.fillRect(-2, -6, 6, 6);
      ctx.fillRect(6, -2, 6, 6);

      ctx.restore();
    }

    // ---------- Surprise sequence ----------
    function startSurprise(){
      if (surpriseStarted) return;
      surpriseStarted = true;
      surpriseBtn.style.display = "none";
      statusHint.textContent = "ðŸ™‚";

      // Start walking in
      sljy.walking = true;
      bouquet.state = "carried";

      // Start fireworks loop
      fireworksOn = true;

      // Play audio (user gesture -> should work on iPhone + Android)
      bdayAudio.currentTime = 0;
      bdayAudio.play().catch(() => {
        // if it fails, it will still be okay visually
      });
    }

    surpriseBtn.addEventListener("click", startSurprise);

    // ---------- Animation loop ----------
    let last = performance.now();

    function update(dt){
      // Walk in
      if (sljy.walking){
        const step = 0.18 * dt; // speed
        sljy.x = Math.max(sljy.targetX, sljy.x - step);

        // Bouquet follows sljy hand area while walking
        if (bouquet.state === "carried"){
          bouquet.x = sljy.x + 22;
          bouquet.y = sljy.y + 12;
        }

        // When reached, place bouquet next to agy96
        if (sljy.x <= sljy.targetX + 0.5){
          sljy.walking = false;

          // "handoff" bouquet ends next to agy96 (NOT in the air)
          bouquet.state = "placed";
          bouquet.x = bouquet.placedX;
          bouquet.y = bouquet.placedY;
        }
      }

      updateFireworks(dt);
    }

    function render(){
      drawBackground();
      drawFireworks();

      drawFurniture();

      // Characters
      drawAgySitting(agy.x, agy.y);

      if (surpriseStarted){
        drawSljy(sljy.x, sljy.y);
      }

      // Bouquet draw
      if (bouquet.state === "carried" || bouquet.state === "placed"){
        drawBouquet(bouquet.x, bouquet.y);
      }

      // Soft vignette
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function loop(now){
      const dt = now - last;
      last = now;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ---------- UX glue ----------
    // Lock â€œone recording onlyâ€
    // - Record starts once, Stop ends it, then Send is available.
    // - Send opens modal with Share sheet + Download fallback.

    // Show surprise button only after "Send to Sandra" flow + returning
    // (handled earlier via visibilitychange/focus)

    // Buttons
    sendBtn.addEventListener("click", () => {
      if (!audioFile){
        statusHint.textContent = "Please record first.";
        return;
      }
      // Open share modal
      shareOverlay.classList.add("show");
      didSendFlow = true;
      statusHint.textContent = "Choose Telegram in the share sheet. Then come back here ðŸ™‚";
    });

    closeShare.addEventListener("click", () => {
      shareOverlay.classList.remove("show");
    });

    // (Record/Stop already wired above)
  </script>
</body>
</html>
