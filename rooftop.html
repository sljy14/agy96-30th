<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rooftop Quiet Time</title>
  <style>
    :root{
      --bg1:#081525;
      --bg2:#0f2742;
      --card: rgba(255,255,255,0.06);
      --stroke: rgba(255,255,255,0.12);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.55);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Inter, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 50% -10%, rgba(255,255,255,0.08), transparent 55%),
                  linear-gradient(180deg,var(--bg1),var(--bg2));
      color: var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding: 18px 14px 28px;
    }
    .wrap{ width:min(760px, 100%); }
    h1{
      margin: 6px 0 8px;
      text-align:center;
      font-size: 34px;
      letter-spacing:-0.5px;
      line-height:1.05;
      font-weight: 800;
      text-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .sub{
      text-align:center;
      color: var(--muted);
      font-size: 14px;
      margin-bottom: 12px;
    }

    .card{
      width:100%;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.07), rgba(255,255,255,0.03));
      padding: 16px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.35);
      position:relative;
      overflow:hidden;
    }
    canvas{
      width:100%;
      height:auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.10);
      display:block;
    }

    .panel{
      margin-top: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      padding: 12px;
    }

    .typed{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(255,255,255,0.92);
      font-size: 13px;
      line-height: 1.55;
      white-space: pre-wrap;
      min-height: 160px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }

    .btn{
      flex: 1 1 180px;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: rgba(255,255,255,0.95);
      font-weight: 800;
      font-size: 15px;
      text-align:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow: 0 18px 48px rgba(0,0,0,0.25);
    }
    .btn:active{ transform: translateY(1px); }
    .btn.disabled{
      opacity: 0.45;
      pointer-events:none;
    }

    .smallHint{
      margin-top: 8px;
      color: var(--muted2);
      font-size: 12px;
      text-align:center;
    }

    /* Mini-surprise popup */
    .popup{
      position:absolute;
      left: 50%;
      top: 18px;
      transform: translateX(-50%);
      width: min(560px, 92%);
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      padding: 12px 14px;
      display:none;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
    }
    .popup.show{ display:flex; }
    .popup .text{
      font-weight: 800;
      color: rgba(255,255,255,0.95);
      font-size: 14px;
    }
    .popup .go{
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      font-weight: 900;
      cursor:pointer;
      white-space:nowrap;
    }

    @media (max-width: 420px){
      h1{ font-size: 30px; }
      .typed{ font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Rooftop Quiet Time üåô</h1>
    <div class="sub">A calm moment ‚Äî record your reflection, then come back for a mini surprise.</div>

    <div class="card" id="card">
      <canvas id="scene" width="720" height="560"></canvas>

      <div class="popup" id="miniPopup">
        <div class="text">Click for a mini surprise! üå∏</div>
        <div class="go" id="miniGo">Open</div>
      </div>

      <div class="panel">
        <div class="typed" id="typed"></div>

        <div class="row">
          <div class="btn" id="recordBtn">üéôÔ∏è Record</div>
          <div class="btn disabled" id="sendBtn">üì§ Send to Sandra</div>
        </div>

        <div class="smallHint" id="hint">
          Tip: after you tap ‚ÄúSend to Sandra‚Äù, choose Telegram and send it to Sandra. Then come back here.
        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Rooftop Scene + Recording + Share + Surprise
    // -----------------------------

    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");

    const typedEl  = document.getElementById("typed");
    const recordBtn = document.getElementById("recordBtn");
    const sendBtn   = document.getElementById("sendBtn");
    const hintEl    = document.getElementById("hint");

    const miniPopup = document.getElementById("miniPopup");
    const miniGo = document.getElementById("miniGo");

    // Audio to play on surprise (place bday.mp3 next to this file)
    const bdayAudio = new Audio("bday.mp3");
    bdayAudio.preload = "auto";

    // Prefilled share message
    const SHARE_TEXT = "here‚Äôs my 30th rooftop reflection ü•π";

    // Typewriter (word-by-word)
    const instructions =
`Follow these instructions carefully.

1. Think about these two questions:
A. Now that you‚Äôve turned 30, What would you tell your 21 year old self?
B. What is your 30 year old birthday wish for yourself?
2. Click on record to start recording your answers
3. Click on ‚ÄúSend to Sandra‚Äù
4. A pop up will appear, send it to Sandra through telegram
5. !Important! Come back to this screen for a mini surprise`;

    function tokenizeWords(text){
      // Keep newlines. Split words but preserve spacing nicely.
      const tokens = [];
      const lines = text.split("\n");
      for (let li=0; li<lines.length; li++){
        const line = lines[li];
        if (line.trim().length === 0){
          tokens.push({t:"\n"});
          continue;
        }
        const parts = line.split(" ");
        for (let i=0;i<parts.length;i++){
          const w = parts[i];
          tokens.push({t: (i===0 ? w : " " + w)});
        }
        if (li !== lines.length-1) tokens.push({t:"\n"});
      }
      return tokens;
    }

    const wordTokens = tokenizeWords(instructions);
    let typeIdx = 0;

    function startTypewriter(){
      typedEl.textContent = "";
      typeIdx = 0;

      const tick = () => {
        if (typeIdx >= wordTokens.length) return;
        typedEl.textContent += wordTokens[typeIdx].t;
        typeIdx++;

        // Speed tuning: punctuation pauses
        const last = wordTokens[typeIdx-1]?.t || "";
        let delay = 70;
        if (last.includes("\n")) delay = 220;
        if (/[.!?]$/.test(last.trim())) delay = 220;

        setTimeout(tick, delay);
      };
      tick();
    }
    startTypewriter();

    // -----------------------------
    // Recording (one take)
    // -----------------------------
    let mediaStream = null;
    let recorder = null;
    let chunks = [];
    let recordedBlob = null;
    let recordedFile = null;
    let isRecording = false;

    function setBtn(el, text, enabled){
      el.textContent = text;
      el.classList.toggle("disabled", !enabled);
    }

    async function startRecording(){
      // iOS Safari requires HTTPS and user gesture (this click counts)
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      chunks = [];
      recordedBlob = null;
      recordedFile = null;

      let mimeType = "";
      // Try to pick a supported mimeType
      const candidates = [
        "audio/webm;codecs=opus",
        "audio/webm",
        "audio/mp4",
        "audio/mpeg"
      ];
      for (const c of candidates){
        if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)){
          mimeType = c;
          break;
        }
      }

      recorder = new MediaRecorder(mediaStream, mimeType ? { mimeType } : undefined);

      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      recorder.onstop = () => {
        recordedBlob = new Blob(chunks, { type: recorder.mimeType || "audio/webm" });

        // Create a File for sharing (iOS share expects File)
        const ext = (recordedBlob.type.includes("mp4")) ? "m4a"
                  : (recordedBlob.type.includes("mpeg")) ? "mp3"
                  : "webm";
        const filename = `rooftop_reflection.${ext}`;

        recordedFile = new File([recordedBlob], filename, { type: recordedBlob.type });

        // Enable Send
        setBtn(sendBtn, "üì§ Send to Sandra", true);

        // Clean up mic stream
        if (mediaStream){
          mediaStream.getTracks().forEach(t => t.stop());
          mediaStream = null;
        }
      };

      recorder.start();
      isRecording = true;
      setBtn(recordBtn, "‚èπ Stop", true);
      setBtn(sendBtn, "üì§ Send to Sandra", false);
      hintEl.textContent = "Recording‚Ä¶ Answer A then B in one take. Tap Stop when done.";
    }

    function stopRecording(){
      if (recorder && isRecording){
        recorder.stop();
      }
      isRecording = false;
      setBtn(recordBtn, "üéôÔ∏è Record again", true);
      hintEl.textContent = "Nice. Now tap ‚ÄúSend to Sandra‚Äù.";
    }

    recordBtn.addEventListener("click", async () => {
      try{
        if (!isRecording){
          await startRecording();
        } else {
          stopRecording();
        }
      } catch (err){
        console.error(err);
        hintEl.textContent = "Mic permission blocked. Please allow microphone access and try again.";
      }
    });

    // -----------------------------
    // Share flow + return detection + popup
    // -----------------------------
    let shareInitiated = false;
    let surpriseReady = false;

    async function shareToSandra(){
      if (!recordedFile) return;

      // Share sheet support check
      if (!navigator.share){
        // Fallback: download blob
        const url = URL.createObjectURL(recordedBlob);
        const a = document.createElement("a");
        a.href = url;
        a.download = recordedFile.name;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1500);

        hintEl.textContent = "Downloaded. Please send the audio to Sandra on Telegram, then come back here for a mini surprise.";
        // We still allow the return-flow popup manually:
        shareInitiated = true;
        return;
      }

      shareInitiated = true;

      try{
        await navigator.share({
          files: [recordedFile],
          text: SHARE_TEXT,
          title: "Rooftop Reflection"
        });
      } catch (err){
        // User may cancel share ‚Äî still ok.
        console.log("Share cancelled or failed:", err);
      }
    }

    sendBtn.addEventListener("click", async () => {
      try{
        hintEl.textContent = "Choose Telegram and send it to Sandra. Then come back here.";
        await shareToSandra();
      } catch (err){
        console.error(err);
        hintEl.textContent = "Sharing failed. Try again, or tell me what device/browser you're on.";
      }
    });

    // When user returns to the page after share sheet / app switch
    function onReturnToPage(){
      if (!shareInitiated || surpriseReady) return;
      surpriseReady = true;

      // 2.5s delay then show popup
      setTimeout(() => {
        miniPopup.classList.add("show");
      }, 2500);
    }

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") onReturnToPage();
    });
    window.addEventListener("focus", () => onReturnToPage());

    // -----------------------------
    // Rooftop Art + Surprise Animation
    // -----------------------------
    // Stars / moon
    const stars = makeStars(90);

    function makeStars(n){
      const arr = [];
      for (let i=0;i<n;i++){
        arr.push({
          x: Math.random()*canvas.width,
          y: Math.random()*170,
          r: 0.6 + Math.random()*1.4,
          tw: Math.random()*Math.PI*2
        });
      }
      return arr;
    }

    // Fireworks particles
    let fireworksOn = false;
    let particles = [];
    let lastFireworkAt = 0;

    function spawnFirework(){
      const cx = 120 + Math.random()*(canvas.width-240);
      const cy = 60 + Math.random()*150;
      const count = 36;

      for (let i=0;i<count;i++){
        const a = (i/count) * Math.PI*2;
        const sp = 1.2 + Math.random()*2.0;
        particles.push({
          x: cx, y: cy,
          vx: Math.cos(a)*sp,
          vy: Math.sin(a)*sp,
          life: 90 + Math.random()*30
        });
      }
    }

    // Surprise actor (you)
    const you = {
      x: -80,
      y: 420,
      targetX: 240,
      walking: false,
      arrived: false,
      bouquetGiven: false
    };

    const bouquet = { show:false, t:0 };

    function startSurprise(){
      miniPopup.classList.remove("show");

      // Reset actor state
      you.x = -80;
      you.walking = true;
      you.arrived = false;
      you.bouquetGiven = false;
      bouquet.show = false;
      bouquet.t = 0;

      // Start walking in
      // Start fireworks only after bouquet is given (per your spec)
      fireworksOn = false;

      // Play audio AFTER bouquet is given; but we can safely preload now
    }

    miniGo.addEventListener("click", () => {
      startSurprise();
    });
    miniPopup.addEventListener("click", () => {
      startSurprise();
    });

    function updateFireworks(){
      const now = performance.now();
      if (fireworksOn && now - lastFireworkAt > 650){
        lastFireworkAt = now;
        spawnFirework();
      }

      // Update particles
      for (const p of particles){
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.01; // tiny gravity
        p.life -= 1;
      }
      particles = particles.filter(p => p.life > 0);
    }

    function drawFireworks(){
      if (particles.length === 0) return;
      ctx.save();
      for (const p of particles){
        const a = Math.max(0, Math.min(1, p.life/120));
        ctx.fillStyle = `rgba(255,255,255,${0.25 + 0.65*a})`;
        ctx.fillRect(p.x, p.y, 2, 2);
      }
      ctx.restore();
    }

    function drawScene(t){
      // Sky gradient
      const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
      g.addColorStop(0, "#04101f");
      g.addColorStop(1, "#0f2742");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.save();
      for (const s of stars){
        const tw = 0.35 + 0.65*(0.5 + 0.5*Math.sin(t/900 + s.tw));
        ctx.fillStyle = `rgba(255,255,255,${0.15 + 0.55*tw})`;
        ctx.fillRect(s.x, s.y, s.r, s.r);
      }
      ctx.restore();

      // Crescent moon
      drawCrescentMoon(610, 80, 22);

      // City skyline (layered)
      drawSkyline();

      // Rooftop deck
      drawRooftopDeck();

      // Fireworks in the sky (behind foreground)
      drawFireworks();

      // agy96 sitting
      drawAgySitting(160, 444);

      // You (walking in)
      drawYouAndBouquet();

      // Vignette
      ctx.fillStyle = "rgba(0,0,0,0.20)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawCrescentMoon(x,y,r){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();

      // Cutout
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(x+8,y-2,r,0,Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";

      // Soft glow
      const rg = ctx.createRadialGradient(x,y,2,x,y,80);
      rg.addColorStop(0,"rgba(255,255,255,0.10)");
      rg.addColorStop(1,"rgba(255,255,255,0.0)");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.arc(x,y,80,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawSkyline(){
      // Far buildings
      ctx.fillStyle = "#1b3f73";
      drawBuildingRow(40, 210, 10, 18, 0.45);

      // Mid buildings
      ctx.fillStyle = "#25518f";
      drawBuildingRow(80, 260, 14, 22, 0.55);

      // Near buildings
      ctx.fillStyle = "#2f68b8";
      drawBuildingRow(130, 320, 18, 28, 0.70);

      // Water band
      ctx.fillStyle = "#062242";
      ctx.fillRect(0, 330, canvas.width, 70);

      // Water sparkles
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      for (let i=0;i<40;i++){
        const x = (i/40) * canvas.width + (Math.sin(i*9)*4);
        const y = 350 + (i%6)*6;
        ctx.fillRect(x, y, 3, 1);
      }
    }

    function drawBuildingRow(yMin, yMax, wMin, wMax, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;
      let x = 0;
      while (x < canvas.width){
        const w = wMin + Math.random()*(wMax-wMin);
        const h = (yMax - yMin) * (0.4 + Math.random()*0.9);
        const y = yMax - h;

        ctx.fillRect(x, y, w, h);

        // Windows (tiny pixels)
        ctx.fillStyle = "rgba(255,255,255,0.18)";
        for (let i=0;i<5;i++){
          const wx = x + 2 + Math.random()*(w-6);
          const wy = y + 4 + Math.random()*(h-10);
          ctx.fillRect(wx, wy, 2, 2);
        }
        ctx.fillStyle = ctx.fillStyle = "#2f68b8"; // reset? (we override below)
        // restore building color by using current fillStyle before windows is messy; keep simple:
        // We'll just set building color each time outside.
        // (So: do nothing here.)
        x += w + 6;
      }
      ctx.restore();

      // Re-apply correct color for next layer (caller sets fillStyle already)
    }

    function drawRooftopDeck(){
      // Deck platform
      ctx.fillStyle = "#101010";
      ctx.fillRect(0, 400, canvas.width, 160);

      // Glass railing
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(80, 370, 560, 38);
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 2;
      ctx.strokeRect(80, 370, 560, 38);

      // Railing posts
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      for (let x=90;x<=630;x+=70){
        ctx.fillRect(x, 370, 4, 38);
      }

      // Couch (inspired by ref)
      ctx.fillStyle = "#6a5a1a";
      ctx.fillRect(110, 430, 210, 70);
      ctx.fillStyle = "#7a6820";
      ctx.fillRect(110, 420, 210, 16);

      // Table
      ctx.fillStyle = "#c8b79a";
      ctx.fillRect(350, 452, 90, 38);
      ctx.fillStyle = "#b8a788";
      ctx.fillRect(360, 444, 70, 10);

      // Plant pot
      ctx.fillStyle = "#d1b06a";
      ctx.fillRect(510, 450, 44, 50);
      ctx.fillStyle = "#c09a58";
      ctx.fillRect(516, 440, 32, 10);
      // Plant
      ctx.fillStyle = "#30c15b";
      ctx.fillRect(520, 418, 24, 24);
      ctx.fillStyle = "#27a94c";
      ctx.fillRect(526, 410, 12, 12);
    }

    // Draw agy96 sitting on couch
    function drawAgySitting(x, y){
      ctx.save();
      ctx.translate(x, y);

      // Name label
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = "bold 12px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("agy96", 0, -70);

      // Hair (thick block)
      ctx.fillStyle = "#0a0a0a";
      ctx.fillRect(-20, -62, 40, 34);
      ctx.fillRect(-22, -58, 4, 30);
      ctx.fillRect(18,  -58, 4, 30);
      ctx.fillRect(-20, -28, 40, 7);

      // Face
      ctx.fillStyle = "#f1c9a8";
      ctx.fillRect(-14, -50, 28, 22);

      // Glasses
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(-12, -46, 10, 8);
      ctx.strokeRect(2, -46, 10, 8);
      ctx.beginPath(); ctx.moveTo(-2, -42); ctx.lineTo(2, -42); ctx.stroke();

      // Torso
      ctx.fillStyle = "#c43737";
      ctx.fillRect(-16, -28, 32, 20);

      // Seated legs (simple)
      ctx.fillStyle = "#1f2530";
      ctx.fillRect(-16, -8, 20, 14);
      ctx.fillRect(0, -8, 16, 10);

      // Shoes
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-16, 6, 22, 6);
      ctx.fillRect(0, 2, 18, 6);

      // Arms
      ctx.fillStyle = "#f1c9a8";
      ctx.fillRect(-20, -26, 4, 16);
      ctx.fillRect(16, -26, 4, 16);

      ctx.restore();
    }

    // "You" avatar walking in + bouquet handoff
    function drawYouAndBouquet(){
      // Update your position
      if (you.walking){
        you.x += 3.2;
        if (you.x >= you.targetX){
          you.x = you.targetX;
          you.walking = false;
          you.arrived = true;

          // after arrive, give bouquet after a short beat
          setTimeout(() => {
            you.bouquetGiven = true;
            bouquet.show = true;
            bouquet.t = 0;

            // Start audio now (user initiated by tapping popup)
            // iOS will allow because this whole sequence started from a click.
            bdayAudio.currentTime = 0;
            bdayAudio.play().catch(()=>{});

            // Start fireworks loop after bouquet is given
            fireworksOn = true;
            lastFireworkAt = performance.now();
          }, 500);
        }
      }

      // Draw you
      ctx.save();
      ctx.translate(you.x, you.y);

      // shadow
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.beginPath();
      ctx.ellipse(0, 26, 26, 8, 0, 0, Math.PI*2);
      ctx.fill();

      // Hair
      ctx.fillStyle = "#111";
      ctx.fillRect(-18, -52, 36, 30);

      // Face
      ctx.fillStyle = "#eab48f";
      ctx.fillRect(-12, -40, 24, 18);

      // Shirt
      ctx.fillStyle = "#2f6fff";
      ctx.fillRect(-14, -22, 28, 22);

      // Pants
      ctx.fillStyle = "#1f2530";
      ctx.fillRect(-14, 0, 28, 18);

      // Shoes
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(-14, 18, 28, 8);

      // Arms
      ctx.fillStyle = "#eab48f";
      // One arm extends when bouquet given
      if (you.bouquetGiven){
        ctx.fillRect(14, -18, 10, 4); // extended arm
      } else {
        ctx.fillRect(14, -18, 4, 16);
      }
      ctx.fillRect(-18, -18, 4, 16);

      ctx.restore();

      // Bouquet between you and agy (once given)
      if (bouquet.show){
        bouquet.t += 1;

        const bx = you.x + 40;
        const by = you.y - 20;

        // Soft glow
        const rg = ctx.createRadialGradient(bx, by, 4, bx, by, 80);
        rg.addColorStop(0, "rgba(255,230,200,0.20)");
        rg.addColorStop(1, "rgba(255,230,200,0.00)");
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(bx, by, 80, 0, Math.PI*2);
        ctx.fill();

        // Flower bunch (pixel cluster)
        ctx.fillStyle = "#ff7ab6";
        ctx.fillRect(bx-8, by-12, 6, 6);
        ctx.fillRect(bx,   by-14, 6, 6);
        ctx.fillRect(bx+8, by-10, 6, 6);
        ctx.fillStyle = "#ffd1e5";
        ctx.fillRect(bx-2, by-6, 6, 6);

        // Leaves
        ctx.fillStyle = "#30c15b";
        ctx.fillRect(bx-6, by, 6, 6);
        ctx.fillRect(bx+6, by, 6, 6);

        // Wrap
        ctx.fillStyle = "#f2e6d6";
        ctx.fillRect(bx-6, by+6, 16, 10);

        // Tiny sparkles
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        if (bouquet.t % 6 === 0){
          ctx.fillRect(bx+22, by-18, 2, 2);
          ctx.fillRect(bx-22, by-6, 2, 2);
        }
      }
    }

    // -----------------------------
    // Animation loop
    // -----------------------------
    let last = performance.now();
    function loop(now){
      const dt = now - last;
      last = now;

      updateFireworks();
      drawScene(now);

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
