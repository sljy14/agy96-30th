<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Waterloo Ballet Studio</title>

  <style>
    :root{
      --cardBg1: rgba(34, 10, 56, 0.70);
      --cardBg2: rgba(16, 6, 26, 0.70);
      --border: rgba(255,255,255,0.12);
      --text: #f6f2ff;
      --muted: rgba(246,242,255,0.76);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 50% -10%, rgba(255,160,220,0.18), transparent 60%),
        radial-gradient(900px 520px at 50% 120%, rgba(130,220,255,0.14), transparent 60%),
        linear-gradient(160deg,#12051d,#060616);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 10px 12px 14px;
    }

    .card{
      width:min(560px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, var(--cardBg1), var(--cardBg2));
      border: 1px solid var(--border);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }

    .header{
      padding: 16px 16px 8px;
      text-align:center;
    }
    h1{
      margin: 0 0 6px;
      font-size: 32px;
      line-height: 1.08;
      font-weight: 900;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .sub{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      padding: 0 14px 10px;
      flex-wrap: wrap;
    }
    .pill{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius: 999px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      letter-spacing: 0.2px;
      min-width: 0;
    }
    .pill small{
      color: var(--muted);
      font-weight: 800;
    }

    .stage{
      padding: 8px 12px 10px;
    }
    .frame{
      border-radius: 20px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      background: #f2eaff;
      touch-action: manipulation;
    }

    .controls{
      position:absolute;
      inset: 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
    }
    .btnArrow{
      pointer-events:auto;
      width: 78px;
      height: 78px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.12);
      display:grid;
      place-items:center;
      user-select:none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: transform 90ms ease;
    }
    .btnArrow:active{ transform: scale(0.96); }

    .btnArrow svg{
      width: 38px;
      height: 38px;
      opacity: 0.9;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.18));
    }

    .hint{
      padding: 0 16px 14px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* popup */
    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 10;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(420px, 96vw);
      background: rgba(18, 8, 28, 0.82);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 30px 90px rgba(0,0,0,0.55);
      padding: 16px 14px 14px;
      text-align:center;
    }
    .modalTitle{
      font-size: 18px;
      font-weight: 900;
      margin: 0 0 10px;
      letter-spacing: -0.01em;
    }
    .modalBtn{
      width: 100%;
      border: 0;
      border-radius: 999px;
      padding: 14px 16px;
      font-weight: 900;
      letter-spacing: 0.2px;
      background: linear-gradient(180deg, rgba(159,240,200,0.22), rgba(159,240,200,0.12));
      border: 1px solid rgba(159,240,200,0.28);
      color: var(--text);
      cursor:pointer;
    }
    .modalBtn:active{ transform: translateY(1px); }
  </style>
</head>

<body>
  <div class="card">
    <div class="header">
      <h1>Welcome to the Waterloo ballet studio! ü©∞</h1>
      <p class="sub">Tap left or right to balance your piqu√© pose.</p>
    </div>

    <div class="hud">
      <div class="pill"><span>‚è±Ô∏è</span><span><strong id="timeLeft">10.0</strong>&nbsp;<small>s left</small></span></div>
      <div class="pill"><span>‚öñÔ∏è</span><span>Balance:&nbsp;<strong id="balanceState">steady</strong></span></div>
    </div>

    <div class="stage">
      <div class="frame">
        <canvas id="game" width="390" height="520" aria-label="Waterloo balance game"></canvas>

        <!-- on-screen arrow buttons -->
        <div class="controls">
          <div id="leftBtn" class="btnArrow" role="button" aria-label="Left">
            <!-- not emoji: clean icon -->
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M14.5 5.5L8 12l6.5 6.5" stroke="rgba(30,35,55,0.95)" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div id="rightBtn" class="btnArrow" role="button" aria-label="Right">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9.5 5.5L16 12l-6.5 6.5" stroke="rgba(30,35,55,0.95)" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <div class="hint">Hold it for 10 seconds. Small wobble ‚Üí tilt ‚Üí drop ‚Üí auto restart.</div>
  </div>

  <!-- Win popup -->
  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal">
      <div class="modalTitle">Congratulations! You balanced with grace under pressure. üôÜ‚Äç‚ôÄÔ∏è</div>
      <button id="nextBtn" class="modalBtn">On to my next mission!</button>
    </div>
  </div>

  <!-- BGM -->
  <audio id="bgm" src="arcade.mp3" preload="auto" loop></audio>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  const timeLeftEl = document.getElementById("timeLeft");
  const balanceStateEl = document.getElementById("balanceState");

  const overlay = document.getElementById("overlay");
  const nextBtn = document.getElementById("nextBtn");

  const bgm = document.getElementById("bgm");
  bgm.volume = 0.6;

  // BGM: start on first user interaction; keep it continuous via localStorage flag
  let bgmStarted = false;
  async function ensureBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    try{
      await bgm.play();
      localStorage.setItem("bgmPlaying","true");
    }catch(e){
      bgmStarted = false;
    }
  }
  if (localStorage.getItem("bgmPlaying")==="true"){
    // may still require a gesture on iOS; we'll try, and try again on first tap
    bgm.play().catch(()=>{});
  }

  // ===== Gameplay model =====
  // We use ‚Äúcue windows‚Äù (missed cue == fail). This is what makes it playable + fair.
  const GAME = {
    totalMs: 10000,
    elapsedMs: 0,
    running: true,
    state: "playing", // playing | dropping | win
    // lean is what you *see*: -1..1
    lean: 0,
    leanVel: 0,
    // cue
    cueDir: 0,          // -1 left, +1 right
    cueDeadline: 0,     // ms timestamp in game time
    cueWindowMs: 900,   // ramps down
    // cosmetics
    shake: 0,
    confetti: []
  };

  function rand(a,b){ return a + Math.random()*(b-a); }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function setBalanceLabel(){
    const a = Math.abs(GAME.lean);
    let label = "steady";
    if (a > 0.55) label = "danger";
    else if (a > 0.28) label = "wobble";
    balanceStateEl.textContent = label;
  }

  // Keep it fair: no more than 2 same directions in a row
  let sameStreak = 0;
  let lastDir = 0;

  function nextCue(nowMs){
    let dir = Math.random() < 0.5 ? -1 : 1;
    if (dir === lastDir) sameStreak++; else sameStreak = 1;
    if (sameStreak >= 3){
      dir *= -1;
      sameStreak = 1;
    }
    lastDir = dir;
    GAME.cueDir = dir;

    // difficulty ramp: 900ms -> 520ms across the 10s
    const t = clamp(GAME.elapsedMs / GAME.totalMs, 0, 1);
    GAME.cueWindowMs = Math.round(900 + (520 - 900) * t);

    // ‚Äúfeel‚Äù of rhythm: cue interval slightly shorter as time passes
    const minI = 480 + (360 - 480) * t;
    const maxI = 760 + (520 - 760) * t;
    const interval = rand(minI, maxI);

    GAME.cueDeadline = nowMs + Math.min(GAME.cueWindowMs, interval);
  }

  function resetGame(){
    GAME.elapsedMs = 0;
    GAME.running = true;
    GAME.state = "playing";
    GAME.lean = 0;
    GAME.leanVel = 0;
    GAME.shake = 0;
    GAME.confetti = [];
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden","true");

    // new cue
    sameStreak = 0;
    lastDir = 0;
    nextCue(0);

    timeLeftEl.textContent = "10.0";
    setBalanceLabel();
  }

  // ===== Input =====
  // ‚ÄúFailure rules: tapped wrong side‚Äù
  // We‚Äôll also fail if a cue is missed (no tap before deadline) because otherwise you can just do nothing and win.
  function handleTap(dir){
    ensureBgm();
    if (!GAME.running || GAME.state !== "playing") return;

    if (dir === GAME.cueDir){
      // Correct: recover toward center + tiny overshoot for satisfaction
      GAME.leanVel += (-GAME.lean) * 0.06;
      GAME.leanVel += dir * 0.09; // gives a little ‚Äúsnap‚Äù
      GAME.shake = 5;

      // Immediately switch to next cue
      nextCue(GAME.elapsedMs);
    } else {
      // Wrong: drop
      triggerDrop();
    }
  }

  leftBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleTap(-1); }, {passive:false});
  rightBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleTap( 1); }, {passive:false});

  // ===== Drop / win =====
  function triggerDrop(){
    if (GAME.state !== "playing") return;
    GAME.state = "dropping";
    GAME.running = false;
    GAME.shake = 10;
    // quick restart after the drop animation
    setTimeout(resetGame, 650);
  }

  function spawnConfetti(){
    const n = 240; // chaotic overload
    for (let i=0;i<n;i++){
      GAME.confetti.push({
        x: canvas.width/2 + rand(-30, 30),
        y: canvas.height*0.42 + rand(-20, 20),
        vx: rand(-2.6, 2.6),
        vy: rand(-4.4, -1.2),
        g: rand(0.06, 0.12),
        r: rand(2.2, 5.0),
        a: rand(0.65, 1.0),
        spin: rand(-0.25, 0.25),
        ang: rand(0, Math.PI*2)
      });
    }
  }

  function win(){
    GAME.state = "win";
    GAME.running = false;
    spawnConfetti();
    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");
  }

  // ===== Drawing helpers =====
  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // Background: clean ballet studio + mirror wall + barre + top lights + spotlight
  function drawStudio(){
    // soft wall gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, "#f7f0ff");
    g.addColorStop(0.55, "#f2e9ff");
    g.addColorStop(1, "#f6d8f0");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // ceiling lights (simple, clean)
    ctx.globalAlpha = 0.8;
    for (let i=0;i<4;i++){
      const x = 60 + i*85;
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      roundedRect(x, 44, 56, 14, 7);
      ctx.fill();
      ctx.fillStyle = "rgba(0,0,0,0.06)";
      roundedRect(x, 58, 56, 3, 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // mirror wall panel
    ctx.fillStyle = "rgba(255,255,255,0.60)";
    roundedRect(22, 90, canvas.width-44, 210, 18);
    ctx.fill();
    // mirror seams
    ctx.strokeStyle = "rgba(150,120,170,0.18)";
    ctx.lineWidth = 2;
    for (let i=1;i<4;i++){
      const x = 22 + (canvas.width-44) * (i/4);
      ctx.beginPath();
      ctx.moveTo(x, 96);
      ctx.lineTo(x, 290);
      ctx.stroke();
    }

    // barre
    ctx.fillStyle = "rgba(180,140,120,0.85)";
    roundedRect(18, 320, canvas.width-36, 14, 7);
    ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,0.07)";
    roundedRect(18, 331, canvas.width-36, 4, 2);
    ctx.fill();
    // barre supports
    ctx.fillStyle = "rgba(110,100,125,0.35)";
    for (let i=0;i<4;i++){
      const x = 70 + i*85;
      ctx.fillRect(x, 332, 6, 54);
    }

    // floor (wood)
    const f = ctx.createLinearGradient(0, 360, 0, canvas.height);
    f.addColorStop(0, "#e7b881");
    f.addColorStop(1, "#d8a76b");
    ctx.fillStyle = f;
    ctx.fillRect(0, 360, canvas.width, canvas.height-360);

    // floor boards
    ctx.strokeStyle = "rgba(120,80,50,0.10)";
    ctx.lineWidth = 2;
    for (let x=20; x<canvas.width; x+=28){
      ctx.beginPath();
      ctx.moveTo(x, 360);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // spotlight cone on dancer
    ctx.globalAlpha = 0.55;
    const cone = ctx.createRadialGradient(canvas.width/2, 250, 10, canvas.width/2, 360, 240);
    cone.addColorStop(0, "rgba(255,255,255,0.95)");
    cone.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = cone;
    ctx.beginPath();
    ctx.ellipse(canvas.width/2, 350, 160, 220, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Cue arrow above head (NOT emoji; pixel-ish arrow)
  function drawCue(){
    const cx = canvas.width/2;
    const cy = 190;

    // faint bubble behind
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,255,0.45)";
    roundedRect(cx-44, cy-34, 88, 64, 18);
    ctx.fill();
    ctx.globalAlpha = 1;

    // arrow drawing
    ctx.fillStyle = "rgba(55, 40, 90, 0.95)";
    const dir = GAME.cueDir; // -1 or +1

    // simple arrow made of rects (pixel vibe)
    // base position
    const x0 = cx + (dir < 0 ? -10 : 10);
    const y0 = cy - 2;

    function px(x,y,w,h){ ctx.fillRect(x,y,w,h); }

    // shaft
    px(x0-10, y0-4, 20, 8);

    // head
    if (dir < 0){
      px(x0-20, y0-10, 10, 20);
      px(x0-28, y0-6, 8, 12);
    } else {
      px(x0+10, y0-10, 10, 20);
      px(x0+20, y0-6, 8, 12);
    }

    // tiny ‚Äúpulse‚Äù outline (so it pops vs the buttons)
    ctx.strokeStyle = "rgba(255, 160, 220, 0.65)";
    ctx.lineWidth = 2;
    ctx.strokeRect(cx-34, cy-24, 68, 44);
  }

  // ===== Avatar: keep your Chinatown face/glasses/hair proportions; change outfit + pose =====
  function drawGlasses(localCtx, leftX, gy, lensW, lensH, thick, gap, armLen){
    localCtx.fillStyle = "#000";
    localCtx.fillRect(leftX, gy, lensW, thick);
    localCtx.fillRect(leftX, gy + lensH - thick, lensW, thick);
    localCtx.fillRect(leftX, gy, thick, lensH);
    localCtx.fillRect(leftX + lensW - thick, gy, thick, lensH);

    const rightX = leftX + lensW + gap;
    localCtx.fillRect(rightX, gy, lensW, thick);
    localCtx.fillRect(rightX, gy + lensH - thick, lensW, thick);
    localCtx.fillRect(rightX, gy, thick, lensH);
    localCtx.fillRect(rightX + lensW - thick, gy, thick, lensH);

    localCtx.fillRect(leftX + lensW, gy + Math.floor(lensH/2) - 1, gap, 2);
    localCtx.fillRect(leftX - armLen, gy + 2, armLen, 2);
    localCtx.fillRect(rightX + lensW, gy + 2, armLen, 2);
  }

  function drawAgyBallet(x, y, lean){
    // y is feet baseline
    // Apply lean by rotating around hips area (looks like tipping)
    const pivotX = x;
    const pivotY = y - 26;

    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(lean * 0.42); // visual tilt (tuned so it won't look insane)
    ctx.translate(-pivotX, -pivotY);

    // hair (same style)
    ctx.fillStyle="#000";
    ctx.fillRect(x-18, y-92, 36, 60);

    // face
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(x-12, y-76, 24, 28);

    // glasses (same)
    const gy = y - 70;
    const lensW = 11, lensH = 9;
    const thick = 2, gap = 5, armLen = 4;
    const leftX = x - 14;
    drawGlasses(ctx, leftX, gy, lensW, lensH, thick, gap, armLen);

    // sleeveless light blue top
    ctx.fillStyle="#8fd1ff";
    ctx.fillRect(x-16, y-48, 32, 22);
    // tiny straps / arm cut (subtle)
    ctx.fillStyle="rgba(0,0,0,0.05)";
    ctx.fillRect(x-16, y-48, 6, 4);
    ctx.fillRect(x+10, y-48, 6, 4);

    // arms: rounded-ish (two curved strokes feel)
    // (still ‚Äúpixel‚Äù but less weird)
    ctx.strokeStyle = "#f1c7a6";
    ctx.lineWidth = 6;
    ctx.lineCap = "round";

    // left rounded arm
    ctx.beginPath();
    ctx.moveTo(x-18, y-44);
    ctx.quadraticCurveTo(x-36, y-58, x-22, y-66);
    ctx.stroke();

    // right rounded arm
    ctx.beginPath();
    ctx.moveTo(x+18, y-44);
    ctx.quadraticCurveTo(x+36, y-58, x+22, y-66);
    ctx.stroke();

    // pink tutu (simple band + skirt flare)
    ctx.fillStyle="#ff9cc7";
    ctx.fillRect(x-22, y-28, 44, 10);
    ctx.fillStyle="#ff84bd";
    ctx.fillRect(x-26, y-18, 52, 16);

    // legs: piqu√©-ish: one straight down on pointe, other slightly behind
    ctx.fillStyle="#f1c7a6";
    // main leg
    ctx.fillRect(x-4, y-2, 8, 34);
    // back leg (diagonal)
    ctx.save();
    ctx.translate(x+8, y+12);
    ctx.rotate(0.42);
    ctx.fillRect(-3, 0, 7, 26);
    ctx.restore();

    // pointe shoes
    ctx.fillStyle="#ffe6f1";
    ctx.fillRect(x-10, y+30, 20, 6); // front shoe
    // back shoe
    ctx.save();
    ctx.translate(x+18, y+30);
    ctx.rotate(0.25);
    ctx.fillRect(-10, 0, 18, 6);
    ctx.restore();

    ctx.restore();

    // soft shadow on floor (doesn't rotate)
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(x, y+34, 34, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ===== Confetti draw/update =====
  function updateConfetti(dt){
    for (const p of GAME.confetti){
      p.x += p.vx * dt * 0.9;
      p.y += p.vy * dt * 0.9;
      p.vy += p.g * dt;
      p.ang += p.spin * dt;
      p.a = Math.max(0, p.a - 0.0009 * dt);
    }
    // prune
    GAME.confetti = GAME.confetti.filter(p => p.a > 0.02 && p.y < canvas.height + 80);
  }

  function drawConfetti(){
    for (const p of GAME.confetti){
      ctx.save();
      ctx.globalAlpha = p.a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.ang);
      // vibrant-ish without hardcoding too many colors:
      const hue = (p.x * 2 + p.y) % 360;
      ctx.fillStyle = `hsla(${hue}, 92%, 68%, ${p.a})`;
      ctx.fillRect(-p.r, -p.r, p.r*2, p.r*2);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  // ===== Main update loop =====
  function update(dt){
    if (GAME.state !== "playing") return;

    GAME.elapsedMs += dt;

    // countdown
    const left = Math.max(0, (GAME.totalMs - GAME.elapsedMs) / 1000);
    timeLeftEl.textContent = left.toFixed(1);

    // win?
    if (GAME.elapsedMs >= GAME.totalMs){
      win();
      return;
    }

    // drift (faster drift, but controllable)
    // cueDir sets where she‚Äôs leaning; we nudge toward cueDir over time
    const t = clamp(GAME.elapsedMs / GAME.totalMs, 0, 1);
    const driftStrength = 0.0022 + 0.0012 * t; // ramps up
    GAME.leanVel += GAME.cueDir * driftStrength * dt;

    // damping
    GAME.leanVel *= 0.985;
    GAME.lean += GAME.leanVel;

    // clamp lean
    GAME.lean = clamp(GAME.lean, -1.2, 1.2);

    // missed cue (no tap before deadline) == fail (otherwise you can AFK win)
    if (GAME.elapsedMs > GAME.cueDeadline){
      triggerDrop();
      return;
    }

    setBalanceLabel();
  }

  function draw(){
    const shakeX = GAME.shake > 0 ? (Math.random()*4 - 2) : 0;
    const shakeY = GAME.shake > 0 ? (Math.random()*4 - 2) : 0;
    if (GAME.shake > 0) GAME.shake -= 1;

    ctx.save();
    ctx.translate(shakeX, shakeY);

    drawStudio();

    // cue arrow bubble (above)
    if (GAME.state === "playing") drawCue();

    // dancer position
    const x = canvas.width/2;
    const y = 390; // baseline on floor
    const visibleLean = GAME.state === "playing" ? GAME.lean : GAME.lean;

    // balance-to-visual mapping (more readable)
    const leanVisual = clamp(visibleLean, -1, 1);

    drawAgyBallet(x, y, leanVisual);

    // balance meter at bottom (visual feedback)
    const barY = canvas.height - 58;
    const barX = 28;
    const barW = canvas.width - 56;
    const barH = 10;

    // base bar
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    roundedRect(barX, barY, barW, barH, 999);
    ctx.fill();
    ctx.globalAlpha = 1;

    // safe zone highlight
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "rgba(120,255,190,0.55)";
    roundedRect(barX + barW*0.35, barY, barW*0.30, barH, 999);
    ctx.fill();
    ctx.globalAlpha = 1;

    // indicator dot
    const p = (leanVisual + 1) / 2; // 0..1
    const dotX = barX + p * barW;
    ctx.fillStyle = "rgba(255,120,190,0.95)";
    ctx.beginPath();
    ctx.arc(dotX, barY + barH/2, 7.5, 0, Math.PI*2);
    ctx.fill();

    // confetti (on win)
    if (GAME.confetti.length) drawConfetti();

    ctx.restore();
  }

  // ===== RAF loop =====
  let last = 0;
  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(33, ts - last);
    last = ts;

    if (GAME.running) update(dt);
    if (GAME.confetti.length) updateConfetti(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ===== Win button: go back to map with stadium prompt =====
  nextBtn.addEventListener("click", () => {
    // Stadium prompt is index 3 in your map.html prompts array
    localStorage.setItem("mapPromptIndex", "3");
    // optional breadcrumb if you ever want it:
    localStorage.setItem("returnFrom", "waterloo");
    location.href = "./map.html";
  });

  // Also allow tap anywhere on canvas to start bgm (iOS-friendly)
  canvas.addEventListener("pointerdown", ()=>ensureBgm(), {passive:true});

  // ===== init =====
  resetGame();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
