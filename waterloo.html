<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Waterloo Ballet Studio</title>
  <style>
    :root{
      --cardBg1: rgba(25, 10, 40, 0.72);
      --cardBg2: rgba(12, 6, 24, 0.70);
      --border: rgba(255,255,255,0.12);
      --text: #f4efff;
      --muted: rgba(244,239,255,0.78);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(900px 520px at 50% 18%, rgba(255,180,230,0.10), transparent 60%),
        radial-gradient(900px 520px at 50% 78%, rgba(160,120,255,0.10), transparent 60%),
        linear-gradient(160deg,#1b0b2e,#060514);
      color: var(--text);
    }
    .wrap{
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 10px 12px 14px;
    }
    .card{
      width:min(560px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, var(--cardBg1), var(--cardBg2));
      border: 1px solid var(--border);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .header{
      padding: 16px 16px 10px;
      text-align:center;
    }
    h1{
      margin: 0 0 6px;
      font-size: 32px;
      line-height: 1.08;
      font-weight: 900;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .sub{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      padding: 0 14px 10px;
      flex-wrap: wrap;
    }
    .pill{
      flex:1;
      min-width: 170px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius: 999px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      letter-spacing: 0.2px;
    }
    .pill small{
      color: var(--muted);
      font-weight: 800;
    }

    .stage{ padding: 8px 12px 12px; }
    .frame{
      border-radius: 20px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px;
      position: relative;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      background: #f3eaff; /* fallback */
      touch-action: manipulation;
    }

    .controls{
      position:absolute;
      inset: 0;
      pointer-events:none; /* buttons will re-enable */
    }
    .btnPad{
      position:absolute;
      top: 52%;
      transform: translateY(-50%);
      width: 82px;
      height: 82px;
      border-radius: 18px;
      background: rgba(255,255,255,0.16);
      border: 1px solid rgba(255,255,255,0.20);
      box-shadow: 0 10px 24px rgba(0,0,0,0.18);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 34px;
      user-select:none;
      pointer-events:auto;
      backdrop-filter: blur(6px);
    }
    .btnPad:active{ transform: translateY(-50%) scale(0.98); }
    .btnLeft{ left: 18px; }
    .btnRight{ right: 18px; }

    .meterWrap{
      padding: 0 16px 14px;
      color: var(--muted);
      font-size: 12px;
      text-align:center;
      line-height:1.35;
    }

    /* Popup */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,0.35);
      z-index: 50;
    }
    .overlay.show{ display:flex; }
    .modal{
      width:min(520px, 100%);
      border-radius: 20px;
      background: rgba(18,10,30,0.86);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 26px 80px rgba(0,0,0,0.55);
      padding: 16px;
      text-align:center;
    }
    .modal h2{
      margin: 6px 0 8px;
      font-size: 18px;
      font-weight: 1000;
      letter-spacing: -0.01em;
    }
    .modal p{
      margin: 0 0 12px;
      color: rgba(244,239,255,0.82);
      font-size: 13px;
    }
    .modal button{
      appearance:none;
      border:0;
      border-radius: 999px;
      padding: 14px 16px;
      width: min(360px, 100%);
      font-weight: 1000;
      letter-spacing: 0.2px;
      background: linear-gradient(180deg, rgba(255,170,210,0.28), rgba(255,170,210,0.14));
      color: var(--text);
      border: 1px solid rgba(255,170,210,0.30);
      cursor:pointer;
    }

    /* keep no scrolling on typical phones */
    @media (max-height: 740px){
      h1{ font-size: 28px; }
      .btnPad{ width: 74px; height: 74px; border-radius: 16px; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <h1>Welcome to the Waterloo ballet studio! ü©∞</h1>
      <p class="sub">Tap left or right to balance your piqu√© pose.</p>
    </div>

    <div class="hud">
      <div class="pill"><span>‚è±Ô∏è</span><span><strong id="timeLeft">10.0</strong><small>&nbsp;s left</small></span></div>
      <div class="pill"><span>‚öñÔ∏è</span><span>Balance:&nbsp;<strong id="balanceText">steady</strong></span></div>
    </div>

    <div class="stage">
      <div class="frame">
        <canvas id="c" width="390" height="520"></canvas>

        <div class="controls" aria-hidden="true">
          <div id="leftBtn" class="btnPad btnLeft" role="button" aria-label="Left">‚¨ÖÔ∏è</div>
          <div id="rightBtn" class="btnPad btnRight" role="button" aria-label="Right">‚û°Ô∏è</div>
        </div>
      </div>
    </div>

    <div class="meterWrap">Hold it for 10 seconds. Small wobble ‚Üí tilt ‚Üí drop ‚Üí auto restart.</div>
  </div>
</div>

<!-- BGM -->
<audio id="bgm" src="arcade.mp3" preload="auto" loop></audio>

<!-- Win popup -->
<div id="overlay" class="overlay" role="dialog" aria-modal="true">
  <div class="modal">
    <h2>Congratulations! You balanced with grace under pressure.</h2>
    <p>Chaotic confetti courtesy of your inner ballerina üí•</p>
    <button id="nextMissionBtn">On to my next mission!</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const timeLeftEl = document.getElementById("timeLeft");
  const balanceTextEl = document.getElementById("balanceText");

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  const overlay = document.getElementById("overlay");
  const nextMissionBtn = document.getElementById("nextMissionBtn");

  const bgm = document.getElementById("bgm");
  let bgmStarted = false;
  async function ensureBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    try{
      bgm.volume = 0.7;
      await bgm.play();
      localStorage.setItem("bgmPlaying","true");
    }catch(e){
      bgmStarted = false;
    }
  }
  // If already playing in other scenes, try autoplay; iOS may still block until tap.
  if (localStorage.getItem("bgmPlaying")==="true") ensureBgm();

  const rand = (a,b)=>a + Math.random()*(b-a);

  // ===== Game State =====
  const HOLD_MS = 10000;

  const state = {
    running: true,
    won: false,
    tStart: performance.now(),
    holdLeft: HOLD_MS,

    // balance in [-1.2, 1.2] where |balance|>1 => drop
    balance: 0,
    balVel: 0,

    // drift that changes direction randomly
    driftTarget: 0,
    driftT: 0,

    // tap impulse (stronger than drift)
    tapImpulse: 0.22,

    // visuals
    confetti: [],
    confettiOn: false
  };

  function resetRun(){
    state.running = true;
    state.won = false;
    state.tStart = performance.now();
    state.holdLeft = HOLD_MS;

    state.balance = 0;
    state.balVel = 0;
    state.driftTarget = rand(-0.30, 0.30);
    state.driftT = 0;

    state.confetti = [];
    state.confettiOn = false;

    overlay.classList.remove("show");
    updateHUD();
  }

  function updateHUD(){
    timeLeftEl.textContent = (state.holdLeft/1000).toFixed(1);

    const a = Math.abs(state.balance);
    let txt = "steady";
    if (a > 0.25) txt = "wobble";
    if (a > 0.55) txt = "tilting";
    if (a > 0.82) txt = "danger";
    balanceTextEl.textContent = txt;
  }

  // ===== Input =====
  function nudge(dir){
    ensureBgm();
    if (!state.running || state.won) return;
    state.balVel += dir * state.tapImpulse; // impulse to velocity (feels responsive)
  }

  const bindHold = (el, dir) => {
    let held = false;
    let holdRAF = 0;

    const start = (e) => {
      e.preventDefault();
      ensureBgm();
      held = true;
      // immediate nudge
      nudge(dir);

      const tick = () => {
        if (!held) return;
        // gentle repeat while held (not too OP)
        state.balVel += dir * (state.tapImpulse * 0.25);
        holdRAF = requestAnimationFrame(tick);
      };
      holdRAF = requestAnimationFrame(tick);
    };

    const end = () => {
      held = false;
      if (holdRAF) cancelAnimationFrame(holdRAF);
      holdRAF = 0;
    };

    el.addEventListener("pointerdown", start, {passive:false});
    window.addEventListener("pointerup", end);
    window.addEventListener("pointercancel", end);
    window.addEventListener("blur", end);
  };

  bindHold(leftBtn, -1);
  bindHold(rightBtn, +1);

  // Also allow tapping anywhere left/right of center on canvas
  canvas.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) * (canvas.width / r.width);
    nudge(x < canvas.width/2 ? -1 : +1);
  }, {passive:false});

  // ===== Avatar (pixel-ish, clean proportions) =====
  function drawGlassesLocal(x, y){
    // y is top of lens row
    ctx.fillStyle = "#000";
    const thick = 2;
    const lensW = 12, lensH = 9, gap = 5;

    const leftX = x - (lensW*2 + gap)/2;
    // left lens
    ctx.fillRect(leftX, y, lensW, thick);
    ctx.fillRect(leftX, y + lensH - thick, lensW, thick);
    ctx.fillRect(leftX, y, thick, lensH);
    ctx.fillRect(leftX + lensW - thick, y, thick, lensH);

    const rightX = leftX + lensW + gap;
    ctx.fillRect(rightX, y, lensW, thick);
    ctx.fillRect(rightX, y + lensH - thick, lensW, thick);
    ctx.fillRect(rightX, y, thick, lensH);
    ctx.fillRect(rightX + lensW - thick, y, thick, lensH);

    // bridge
    ctx.fillRect(leftX + lensW, y + Math.floor(lensH/2) - 1, gap, 2);
    // small arms
    ctx.fillRect(leftX - 4, y + 2, 4, 2);
    ctx.fillRect(rightX + lensW, y + 2, 4, 2);
  }

  function drawBalletAgy(cx, cy, tiltRad){
    // cx,cy is "feet baseline-ish" for the standing leg area
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(tiltRad);
    ctx.translate(-cx, -cy);

    // proportions tuned to look like Chinatown but in tutu + pose
    const x = cx;
    const y = cy; // baseline reference (near feet)

    // Hair (rectangle blob like Chinatown)
    ctx.fillStyle = "#000";
    ctx.fillRect(x-18, y-150, 36, 62);

    // Face
    ctx.fillStyle = "#f1c7a6";
    ctx.fillRect(x-12, y-136, 24, 30);

    // Glasses
    drawGlassesLocal(x, y-125);

    // Neck (tiny)
    ctx.fillStyle = "#f1c7a6";
    ctx.fillRect(x-4, y-106, 8, 6);

    // Top (sleeveless light blue)
    ctx.fillStyle = "#86c8ff";
    ctx.fillRect(x-15, y-100, 30, 26);

    // Bare arms (rounded-ish)
    ctx.fillStyle = "#f1c7a6";
    // arms rounded (front view) -> two curved-ish segments
    ctx.fillRect(x-28, y-98, 8, 16);
    ctx.fillRect(x+20, y-98, 8, 16);

    // Arms "rounded" (ballet-ish) using arcs + small rects
    ctx.strokeStyle = "rgba(241,199,166,0.95)";
    ctx.lineWidth = 6;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.arc(x, y-92, 26, Math.PI*0.15, Math.PI*0.85, false); // soft rounded arms
    ctx.stroke();

    // Tutu (pink skirt)
    ctx.fillStyle = "#ff8fc2";
    ctx.fillRect(x-22, y-76, 44, 16);
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(x-18, y-72, 36, 2);

    // Legs (piqu√©-ish):
    // Standing leg straight down on pointe
    ctx.fillStyle = "#f1c7a6";
    ctx.fillRect(x-6, y-60, 10, 54);

    // Pointe shoe (standing)
    ctx.fillStyle = "#ffe7ef";
    ctx.fillRect(x-8, y-6, 14, 6);
    ctx.fillStyle = "rgba(0,0,0,0.08)";
    ctx.fillRect(x-8, y-2, 14, 2);

    // Back leg slightly behind, angled
    ctx.save();
    ctx.translate(x+6, y-40);
    ctx.rotate(-0.55);
    ctx.translate(-(x+6), -(y-40));
    ctx.fillStyle = "#f1c7a6";
    ctx.fillRect(x+6, y-40, 8, 44);

    // Back shoe
    ctx.fillStyle = "#ffe7ef";
    ctx.fillRect(x+4, y+2, 14, 6);
    ctx.restore();

    ctx.restore();
  }

  // ===== Studio Background (cleaner, mirror wall + barre + lights + spotlight) =====
  function drawStudio(){
    const W = canvas.width, H = canvas.height;

    // wall gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#f7f0ff");
    g.addColorStop(0.55, "#f3eaff");
    g.addColorStop(1, "#efe0ff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle vignette
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    ctx.fillRect(0,0,W,6);

    // mirror band
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    ctx.fillRect(0, 170, W, 130);
    ctx.fillStyle = "rgba(170,140,210,0.18)";
    ctx.fillRect(0, 170, W, 2);
    ctx.fillRect(0, 300, W, 2);

    // mirror vertical seams
    ctx.fillStyle = "rgba(120,90,160,0.10)";
    for (let x=18; x<W; x+=74){
      ctx.fillRect(x, 176, 2, 118);
    }

    // ballet barre + brackets
    ctx.fillStyle = "rgba(140, 90, 70, 0.55)";
    ctx.fillRect(0, 310, W, 10);
    ctx.fillStyle = "rgba(90, 60, 50, 0.35)";
    for (let x=26; x<W; x+=90){
      ctx.fillRect(x, 320, 8, 28);
    }

    // floor
    ctx.fillStyle = "#e7be8e";
    ctx.fillRect(0, 340, W, H-340);

    // floor planks
    ctx.fillStyle = "rgba(120,80,55,0.12)";
    for (let x=16; x<W; x+=34){
      ctx.fillRect(x, 340, 2, H-340);
    }

    // base shadow line
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0, 340, W, 4);

    // lights above (simple)
    for (let i=0;i<4;i++){
      const lx = 60 + i*90;
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      ctx.fillRect(lx, 40, 46, 10);
      ctx.fillStyle = "rgba(255,255,255,0.38)";
      ctx.fillRect(lx+6, 52, 34, 6);
    }

    // spotlight cone (center)
    const spot = ctx.createRadialGradient(W/2, 210, 10, W/2, 260, 250);
    spot.addColorStop(0, "rgba(255,255,255,0.70)");
    spot.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = spot;
    ctx.fillRect(0,0,W,H);
  }

  // ===== Balance Meter =====
  function drawBalanceMeter(){
    const W = canvas.width, H = canvas.height;

    const barX = 34;
    const barY = H - 44;
    const barW = W - 68;
    const barH = 10;

    // track
    ctx.fillStyle = "rgba(0,0,0,0.14)";
    ctx.fillRect(barX, barY, barW, barH);

    // safe zone
    ctx.fillStyle = "rgba(120,255,190,0.25)";
    ctx.fillRect(barX + barW*0.30, barY, barW*0.40, barH);

    // danger tint ends
    ctx.fillStyle = "rgba(255,120,150,0.18)";
    ctx.fillRect(barX, barY, barW*0.22, barH);
    ctx.fillRect(barX + barW*0.78, barY, barW*0.22, barH);

    // knob from balance [-1..1]
    const clamped = Math.max(-1, Math.min(1, state.balance));
    const t = (clamped + 1) / 2; // 0..1
    const knobX = barX + t * barW;

    ctx.fillStyle = "#ff77b7";
    ctx.beginPath();
    ctx.arc(knobX, barY + barH/2, 9, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.beginPath();
    ctx.arc(knobX-2, barY + barH/2 - 2, 3, 0, Math.PI*2);
    ctx.fill();
  }

  // ===== Confetti =====
  function startConfettiExplosion(){
    state.confettiOn = true;
    state.confetti = [];
    const W = canvas.width;

    // overload üí•
    const N = 220;
    for (let i=0;i<N;i++){
      const angle = rand(-Math.PI, 0);     // mostly downward burst
      const speed = rand(3.0, 9.0);
      state.confetti.push({
        x: W/2 + rand(-10,10),
        y: 140 + rand(-10,10),
        vx: Math.cos(angle)*speed + rand(-1.5,1.5),
        vy: Math.sin(angle)*speed + rand(-1.0,2.0),
        g: rand(0.08, 0.16),
        s: rand(3,7),
        a: rand(0.55, 1.0),
        rot: rand(0, Math.PI*2),
        vr: rand(-0.18, 0.18)
      });
    }
  }

  function drawConfetti(dt){
    if (!state.confettiOn) return;
    const H = canvas.height, W = canvas.width;

    for (const p of state.confetti){
      p.vy += p.g * dt;
      p.x += p.vx * dt * 0.35;
      p.y += p.vy * dt * 0.35;
      p.rot += p.vr * dt * 0.18;

      ctx.save();
      ctx.globalAlpha = p.a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);

      // random bright colors
      const colors = ["#ff5aa7","#7df0ff","#ffe36a","#9cff7b","#b28dff","#ff9c6a"];
      ctx.fillStyle = colors[(p.s * 13 + (p.x|0)) % colors.length];
      ctx.fillRect(-p.s/2, -p.s/2, p.s, p.s*0.7);

      ctx.restore();
    }

    // stop once all below bottom (but keep some)
    if (state.confetti.every(p => p.y > H + 60)){
      state.confettiOn = false;
    }
  }

  // ===== Game Loop =====
  function step(dt){
    if (!state.running || state.won) return;

    // countdown
    state.holdLeft = Math.max(0, HOLD_MS - (performance.now() - state.tStart));

    // drift target changes every ~0.7s
    state.driftT += dt;
    if (state.driftT > 700){
      state.driftT = 0;
      state.driftTarget = rand(-0.45, 0.45); // faster drift, but not insane
    }

    // physics: balance accelerates toward driftTarget
    // Make failing possible: if you do nothing, it will walk to the edge.
    const driftForce = state.driftTarget * 0.0021;
    state.balVel += driftForce * dt;

    // damping (keeps it controllable)
    state.balVel *= 0.985;

    // integrate
    state.balance += state.balVel * dt * 0.18;

    // clamps beyond drop threshold
    const absB = Math.abs(state.balance);

    // WIN
    if (state.holdLeft <= 0){
      state.won = true;
      state.running = false;
      startConfettiExplosion();
      setTimeout(() => overlay.classList.add("show"), 380);
    }

    // FAIL: drop
    if (absB > 1.02){
      // small wobble -> tilt -> drop -> auto restart
      state.running = false;
      setTimeout(() => {
        resetRun();
      }, 520);
    }

    updateHUD();
  }

  function draw(dt){
    drawStudio();

    // dancer position
    const cx = canvas.width/2;
    const cy = 340; // near floor top

    // tilt based on balance (soft)
    const tilt = Math.max(-0.18, Math.min(0.18, state.balance * 0.18)); // rad clamp

    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.beginPath();
    ctx.ellipse(cx, 404, 44, 10, 0, 0, Math.PI*2);
    ctx.fill();

    drawBalletAgy(cx, 402, tilt);
    drawBalanceMeter();

    // confetti on top
    drawConfetti(dt);
  }

  let last = 0;
  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(33, ts - last);
    last = ts;

    step(dt);
    draw(dt);

    requestAnimationFrame(loop);
  }

  // ===== Button: go back to map with Stadium prompt =====
  const MAP_URL = "./map.html"; // <-- change if your map file has a different name
  nextMissionBtn.addEventListener("click", () => {
    // Stadium is prompt index 3 in your prompt order.
    localStorage.setItem("mapPromptIndex", "3");
    location.href = MAP_URL;
  });

  // Start
  resetRun();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
