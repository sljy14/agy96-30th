<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Waterloo Ballet Studio</title>
  <style>
    :root{
      --cardBg1: rgba(34, 8, 60, 0.78);
      --cardBg2: rgba(10, 7, 22, 0.72);
      --border: rgba(255,255,255,0.12);
      --text: #f3f0ff;
      --muted: rgba(243,240,255,0.78);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1100px 620px at 50% 10%, rgba(210,170,255,0.18), transparent 55%),
        radial-gradient(900px 520px at 50% 80%, rgba(140,255,220,0.10), transparent 62%),
        linear-gradient(160deg,#0a1632,#090615);
      color: var(--text);
    }
    .wrap{
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 10px 12px 14px;
    }
    .card{
      width:min(560px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, var(--cardBg1), var(--cardBg2));
      border: 1px solid var(--border);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }
    .header{
      padding: 16px 16px 10px;
      text-align:center;
    }
    h1{
      margin: 0 0 6px;
      font-size: 34px;
      line-height: 1.05;
      font-weight: 1000;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .sub{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      padding: 0 14px 10px;
      flex-wrap: wrap;
    }
    .pill{
      flex:1;
      min-width: 160px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius: 999px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      letter-spacing: 0.2px;
    }
    .pill small{
      color: var(--muted);
      font-weight: 800;
    }

    .stage{
      padding: 8px 12px 12px;
    }
    .frame{
      position: relative;
      border-radius: 20px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px;
      overflow: hidden;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      background: #f3eaff;
      touch-action: manipulation;
    }

    /* control center */
    .controls{
      position:absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      display:flex;
      gap: 14px;
      z-index: 5;
      pointer-events: auto;
    }
    .btn{
      width: 76px;
      height: 76px;
      border-radius: 18px;
      background: rgba(255,255,255,0.55);
      border: 1px solid rgba(255,255,255,0.50);
      box-shadow: 0 10px 26px rgba(0,0,0,0.16);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 38px;
      font-weight: 900;
      color: rgba(0,0,0,0.72);
      user-select:none;
      cursor:pointer;
      backdrop-filter: blur(6px);
    }
    .btn:active{ transform: translateY(1px) scale(0.98); }
    .btnRowHint{
      padding: 0 16px 14px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* win overlay */
    .overlay{
      position:absolute;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 10;
      pointer-events:auto;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(420px, 92%);
      border-radius: 22px;
      background: rgba(255,255,255,0.18);
      border: 1px solid rgba(255,255,255,0.28);
      box-shadow: 0 30px 80px rgba(0,0,0,0.45);
      padding: 18px 16px 16px;
      text-align:center;
      backdrop-filter: blur(8px);
    }
    .modal h2{
      margin: 0 0 8px;
      font-size: 20px;
      font-weight: 1000;
      letter-spacing: -0.01em;
    }
    .modal p{
      margin: 0 0 14px;
      color: rgba(255,255,255,0.82);
      font-size: 13px;
      line-height: 1.35;
    }
    .modal button{
      width: 100%;
      border: 0;
      border-radius: 999px;
      padding: 14px 16px;
      font-weight: 1000;
      letter-spacing: 0.2px;
      background: linear-gradient(180deg, rgba(255,190,230,0.30), rgba(255,190,230,0.14));
      color: var(--text);
      border: 1px solid rgba(255,190,230,0.34);
      cursor:pointer;
    }
    .modal button:active{ transform: translateY(1px); }

    @media (max-width: 360px){
      h1{ font-size: 30px; }
      .btn{ width: 70px; height: 70px; font-size: 34px; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="card">

    <div class="header">
      <h1>Welcome to the Waterloo ballet studio! ü©∞</h1>
      <p class="sub">Tap ‚Üê, ‚Üë, or ‚Üí to balance your piqu√© pose.</p>
    </div>

    <div class="hud">
      <div class="pill"><span>üéØ</span><span>Hits:&nbsp;<strong id="hits">0</strong>&nbsp;<small>/ 10</small></span></div>
      <div class="pill"><span>‚è≥</span><span>Time:&nbsp;<strong id="timer">1.6</strong><small>s</small></span></div>
      <div class="pill"><span>üôà</span><span>Falls:&nbsp;<strong id="falls">0</strong></span></div>
    </div>

    <div class="stage">
      <div class="frame">
        <canvas id="c" width="390" height="520" aria-label="Waterloo ballet game"></canvas>

        <div class="controls" aria-label="controls">
          <div class="btn" id="leftBtn" role="button" aria-label="left">‚Äπ</div>
          <div class="btn" id="upBtn" role="button" aria-label="up">ÀÑ</div>
          <div class="btn" id="rightBtn" role="button" aria-label="right">‚Ä∫</div>
        </div>

        <div class="overlay" id="overlay">
          <div class="modal">
            <h2>Congratulations! You balanced with grace under pressure. üôÜ‚Äç‚ôÄÔ∏è</h2>
            <p>Ready for the next mission?</p>
            <button id="nextBtn">On to my next adventure!</button>
          </div>
        </div>

      </div>
    </div>

    <div class="btnRowHint">10 correct cues. Each cue must be tapped within 1.6 seconds. Wrong or late = drop + instant restart.</div>
  </div>
</div>

<!-- BGM -->
<audio id="bgm" src="./arcade.mp3" preload="auto" loop></audio>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const hitsEl = document.getElementById("hits");
  const timerEl = document.getElementById("timer");
  const fallsEl = document.getElementById("falls");
  const overlay = document.getElementById("overlay");
  const nextBtn = document.getElementById("nextBtn");

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");
  const upBtn = document.getElementById("upBtn");

  const bgm = document.getElementById("bgm");

  // ===== BGM (iOS friendly + persists across pages) =====
  let bgmStarted = false;
  async function ensureBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    try{
      bgm.volume = 0.7;
      await bgm.play();
      localStorage.setItem("bgmPlaying","true");
    }catch(e){
      bgmStarted = false;
    }
  }
  if (localStorage.getItem("bgmPlaying")==="true"){
    // try autoplay (may fail, will succeed on first tap)
    ensureBgm();
  }

  // ===== GAME SETTINGS =====
  const GOAL = 10;
  const WINDOW_MS = 1600;      // your chosen 1.6s
  const BETWEEN_MS = 140;      // tiny pause between cues so it never flickers
  const rand = (a,b)=>a + Math.random()*(b-a);

  // ===== STATE =====
  const game = {
    state: "playing", // playing | falling | winAnim | winModal
    hits: 0,
    falls: 0,
    cue: null,         // {dir:'left'|'right'|'up', shownAt, deadline, id}
    lastCueAt: 0,
    tilt: 0,           // current tilt radians
    tiltTarget: 0,
    wobbleT: 0,
    jumpT: -1,         // -1 none, else 0..1
    fallT: -1,
    confetti: [],
    confettiT: 0,
    winT: 0,
    winJumps: 0
  };

  // dancer anchor (we keep her ABOVE the buttons)
  const dancer = {
    x: canvas.width/2,
    y: canvas.height - 140, // just above button row
    scale: 1.0
  };

  // ===== HUD =====
  function setHUD(){
    hitsEl.textContent = String(game.hits);
    fallsEl.textContent = String(game.falls);
    if (game.cue && game.state === "playing"){
      const remain = Math.max(0, (game.cue.deadline - performance.now())/1000);
      timerEl.textContent = remain.toFixed(1);
    } else {
      timerEl.textContent = (WINDOW_MS/1000).toFixed(1);
    }
  }

  // ===== CUE SYSTEM =====
  function newCue(){
    const now = performance.now();
    const dirs = ["left","right","up"];
    const dir = dirs[Math.floor(Math.random()*dirs.length)];
    game.cue = {
      dir,
      shownAt: now,
      deadline: now + WINDOW_MS,
      id: (game.cue ? game.cue.id + 1 : 1)
    };
    game.lastCueAt = now;

    // tilt is OPPOSITE cue (your rule)
    if (dir === "left")  game.tiltTarget = +0.42;   // cue left -> she tips RIGHT
    if (dir === "right") game.tiltTarget = -0.42;   // cue right -> she tips LEFT
    if (dir === "up")    game.tiltTarget = (Math.random()>0.5 ? 0.14 : -0.14); // a tiny lean, but jump is the effect
  }

  function resetRound(){
    overlay.classList.remove("show");
    game.state = "playing";
    game.hits = 0;
    game.tilt = 0;
    game.tiltTarget = 0;
    game.wobbleT = 0;
    game.jumpT = -1;
    game.fallT = -1;
    game.confetti = [];
    game.confettiT = 0;
    game.winT = 0;
    game.winJumps = 0;
    setHUD();
    newCue();
  }

  // ===== INPUT =====
  function handlePick(pick){
    ensureBgm();

    if (game.state !== "playing") return;
    if (!game.cue) return;

    const now = performance.now();
    const correct = (pick === game.cue.dir);
    const late = (now > game.cue.deadline);

    if (!correct || late){
      failDrop();
      return;
    }

    // success
    game.hits++;

    // straighten immediately
    game.tiltTarget = 0;

    // quick jump on UP
    if (pick === "up"){
      game.jumpT = 0;
    }

    setHUD();

    if (game.hits >= GOAL){
      winSequence();
      return;
    }

    // delay then next cue (prevents flicker + ensures repeat cues feel like "new")
    const cueIdAtTap = game.cue.id;
    game.cue = null;
    setTimeout(() => {
      // if still same run
      if (game.state === "playing" && game.hits < GOAL){
        // cue id increments even if same direction repeats
        const prev = { id: cueIdAtTap };
        game.cue = prev; // temporary so newCue increments consistently
        newCue();
      }
    }, BETWEEN_MS);
  }

  function failDrop(){
    game.falls++;
    setHUD();
    game.state = "falling";
    game.fallT = 0;
  }

  // ===== WIN =====
  function spawnConfetti(){
    const colors = ["#ff6bb5","#7cf5d2","#ffd35a","#9d7bff","#4fd2ff","#ff8a5a","#7ef07a"];
    game.confetti = Array.from({length: 140}, () => ({
      x: rand(0, canvas.width),
      y: rand(-canvas.height, 0),
      w: rand(6, 14),
      h: rand(6, 14),
      vy: rand(180, 420),
      vx: rand(-90, 90),
      rot: rand(0, Math.PI*2),
      vr: rand(-6, 6),
      a: rand(0.72, 1),
      c: colors[Math.floor(Math.random()*colors.length)]
    }));
  }

  function winSequence(){
    game.state = "winAnim";
    game.cue = null;
    game.tiltTarget = 0;
    game.tilt = 0;
    game.winT = 0;
    game.winJumps = 0;
    game.confettiT = 0;
    spawnConfetti();
  }

  // ===== DRAW HELPERS =====
  function roundRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // Glasses (exact MacRitchie proportions)
  function drawGlasses(c, leftX, gy, lensW, lensH, thick, gap, armLen){
    c.fillStyle = "#000";
    // left
    c.fillRect(leftX, gy, lensW, thick);
    c.fillRect(leftX, gy + lensH - thick, lensW, thick);
    c.fillRect(leftX, gy, thick, lensH);
    c.fillRect(leftX + lensW - thick, gy, thick, lensH);

    const rightX = leftX + lensW + gap;
    // right
    c.fillRect(rightX, gy, lensW, thick);
    c.fillRect(rightX, gy + lensH - thick, lensW, thick);
    c.fillRect(rightX, gy, thick, lensH);
    c.fillRect(rightX + lensW - thick, gy, thick, lensH);

    // bridge
    c.fillRect(leftX + lensW, gy + Math.floor(lensH/2) - 1, gap, 2);

    // arms
    c.fillRect(leftX - armLen, gy + 2, armLen, 2);
    c.fillRect(rightX + lensW, gy + 2, armLen, 2);
  }

  function drawHeadFace(c){
    // local space: hair box centered at 0,0 (top-left at -18,-60)
    const x = -18, y = -60;

    // hair
    c.fillStyle = "#000";
    c.fillRect(x, y, 36, 60);

    // face
    c.fillStyle = "#f1c7a6";
    c.fillRect(x + 6, y + 16, 24, 28);

    // glasses
    const gy = y + 22;
    const lensW = 11, lensH = 9;
    const thick = 2, gap = 5, armLen = 4;
    const leftX = x + 4;
    drawGlasses(c, leftX, gy, lensW, lensH, thick, gap, armLen);
  }

  function drawArmsArc(c){
    // arms as two smooth arcs (like your reference)
    c.strokeStyle = "#f1c7a6";
    c.lineWidth = 8;
    c.lineCap = "round";

    // left arc
    c.beginPath();
    c.arc(-14, -2, 20, Math.PI*1.05, Math.PI*1.75, false);
    c.stroke();

    // right arc
    c.beginPath();
    c.arc(14, -2, 20, Math.PI*1.25, Math.PI*1.95, false);
    c.stroke();
  }

  function drawDancer(c, tiltRad, jumpOffset){
    c.save();
    c.translate(dancer.x, dancer.y + jumpOffset);
    c.scale(dancer.scale, dancer.scale);
    c.rotate(tiltRad);

    // shirt (sleeveless light blue)
    c.fillStyle = "#9fd0ff";
    c.fillRect(-16, -10, 32, 42);

    // neckline hint
    c.fillStyle = "rgba(255,255,255,0.18)";
    c.fillRect(-14, -8, 28, 3);

    // tutu (pink) - keeps your clean blocky style
    c.fillStyle = "#ff7dbf";
    c.fillRect(-24, 26, 48, 16);
    c.fillStyle = "rgba(255,255,255,0.18)";
    c.fillRect(-22, 28, 44, 3);

    // arms (arc)
    drawArmsArc(c);

    // head (exact proportions)
    drawHeadFace(c);

    // legs (improved: thigh starts under tutu, not from standing knee)
    // standing leg (left)
    c.fillStyle = "#f1c7a6";
    c.fillRect(-6, 42, 12, 54);

    // pointe shoe
    c.fillStyle = "#fff";
    c.fillRect(-8, 92, 16, 8);

    // bent leg: horizontal thigh near tutu, shin angled back towards standing leg
    // thigh
    c.fillStyle = "#f1c7a6";
    c.fillRect(6, 50, 26, 10); // starts near tutu
    // shin (diagonal-ish using 2 rectangles)
    c.fillRect(26, 58, 10, 22);
    c.fillRect(20, 74, 14, 10);

    // shoe on bent leg
    c.fillStyle = "#fff";
    c.fillRect(20, 84, 18, 8);

    c.restore();
  }

  function drawNameTag(c, text, x, y){
    c.save();
    c.textAlign = "center";
    c.font = "12px Arial";
    c.fillStyle = "rgba(255,255,255,0.92)";
    c.shadowColor = "rgba(0,0,0,0.35)";
    c.shadowBlur = 6;
    c.fillText(text, x, y);
    c.restore();
  }

  function drawStudioBackground(){
    const W = canvas.width, H = canvas.height;

    // soft purple gradient
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#f7efff");
    g.addColorStop(0.55, "#f3e6ff");
    g.addColorStop(1, "#f8d7e7");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // mirror wall panel
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,0.55)";
    roundRect(ctx, 16, 40, W-32, 250, 18);
    ctx.fill();
    ctx.restore();

    // mirror lines
    ctx.strokeStyle = "rgba(155,120,170,0.24)";
    ctx.lineWidth = 2;
    for (let x=50; x<W; x+=70){
      ctx.beginPath();
      ctx.moveTo(x, 54);
      ctx.lineTo(x, 276);
      ctx.stroke();
    }

    // light panels at top
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    for (let i=0;i<4;i++){
      roundRect(ctx, 34 + i*90, 58, 56, 14, 7);
      ctx.fill();
    }

    // ballet barre
    ctx.fillStyle = "rgba(140,120,120,0.65)";
    ctx.fillRect(32, 320, W-64, 10);
    ctx.fillStyle = "rgba(120,110,110,0.55)";
    for (let i=0;i<6;i++){
      ctx.fillRect(54 + i*60, 330, 8, 70);
    }

    // floor
    const fg = ctx.createLinearGradient(0, 360, 0, H);
    fg.addColorStop(0, "#f0cfa8");
    fg.addColorStop(1, "#e7b47e");
    ctx.fillStyle = fg;
    ctx.fillRect(0, 360, W, H-360);

    // floor planks
    ctx.strokeStyle = "rgba(140,90,70,0.18)";
    ctx.lineWidth = 2;
    for (let x=20; x<W; x+=28){
      ctx.beginPath();
      ctx.moveTo(x, 365);
      ctx.lineTo(x, H);
      ctx.stroke();
    }

    // spotlight on dancer area
    ctx.save();
    ctx.globalAlpha = 0.26;
    const spot = ctx.createRadialGradient(W/2, 380, 20, W/2, 380, 240);
    spot.addColorStop(0, "rgba(255,255,255,0.95)");
    spot.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = spot;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // soft diagonal beam
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.moveTo(W*0.64, 60);
    ctx.lineTo(W*0.92, 60);
    ctx.lineTo(W*0.74, H);
    ctx.lineTo(W*0.46, H);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawCueBubble(){
    if (!game.cue) return;

    const W = canvas.width;
    const now = performance.now();
    const t = Math.min(1, (now - game.cue.shownAt)/140); // pop-in
    const pop = 0.92 + 0.08*Math.sin(Math.PI*t);

    // bubble position ABOVE head
    const bx = dancer.x;
    const by = dancer.y - 175;

    ctx.save();
    ctx.translate(bx, by);
    ctx.scale(pop, pop);

    // bubble
    ctx.fillStyle = "rgba(255,255,255,0.86)";
    ctx.strokeStyle = "rgba(255,120,190,0.55)";
    ctx.lineWidth = 3;
    roundRect(ctx, -48, -34, 96, 68, 18);
    ctx.fill();
    ctx.stroke();

    // emoji
    ctx.font = "34px Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    let emoji = "üëâ";
    if (game.cue.dir === "left") emoji = "üëà";
    if (game.cue.dir === "right") emoji = "üëâ";
    if (game.cue.dir === "up") emoji = "üëÜ";

    ctx.fillText(emoji, 0, 3);

    ctx.restore();
  }

  function drawShadow(){
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(dancer.x, dancer.y + 110, 70, 18, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawConfetti(dt){
    if (!game.confetti.length) return;
    const H = canvas.height;

    for (const p of game.confetti){
      p.x += p.vx * (dt/1000);
      p.y += p.vy * (dt/1000);
      p.rot += p.vr * (dt/1000);

      // wrap a bit
      if (p.y > H + 30) p.y = -30;
      if (p.x < -30) p.x = canvas.width + 30;
      if (p.x > canvas.width + 30) p.x = -30;
    }

    ctx.save();
    for (const p of game.confetti){
      ctx.globalAlpha = p.a;
      ctx.fillStyle = p.c;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.setTransform(1,0,0,1,0,0);
    }
    ctx.restore();
  }

  // ===== UPDATE LOOP =====
  let last = 0;

  function update(dt){
    const now = performance.now();

    // smooth tilt towards target
    game.tilt += (game.tiltTarget - game.tilt) * 0.12;

    // jump anim
    if (game.jumpT >= 0){
      game.jumpT += dt/260;
      if (game.jumpT >= 1) game.jumpT = -1;
    }

    // timeout fail
    if (game.state === "playing" && game.cue){
      if (now > game.cue.deadline){
        failDrop();
      }
    }

    // falling anim
    if (game.state === "falling"){
      game.fallT += dt;
      // after short drop, instant restart
      if (game.fallT > 520){
        game.state = "playing";
        game.tilt = 0;
        game.tiltTarget = 0;
        game.jumpT = -1;
        game.fallT = -1;
        game.hits = 0;
        setHUD();
        newCue();
      }
    }

    // win anim: keep scene, jump 3x, confetti for >=2s, then show modal
    if (game.state === "winAnim"){
      game.winT += dt;

      // 3 jumps across ~900ms
      const jumpPeriod = 300;
      const totalJumpTime = 900;
      if (game.winT <= totalJumpTime){
        // nothing to set; jump offset computed in draw
      }

      game.confettiT += dt;
      if (game.confettiT >= 2000){
        game.state = "winModal";
        overlay.classList.add("show");
      }
    }

    setHUD();
  }

  // ===== DRAW LOOP =====
  function draw(dt){
    drawStudioBackground();

    // shadow
    drawShadow();

    // dancer state
    let tilt = game.tilt;

    // falling: dramatic drop straight down (no weird spin)
    let extraY = 0;
    if (game.state === "falling"){
      const t = Math.min(1, game.fallT / 520);
      extraY = 220 * t * t;
      tilt = tilt * (1 - t);
    }

    // win: upright
    if (game.state === "winAnim" || game.state === "winModal"){
      tilt = 0;
    }

    // jump offset
    let jumpOffset = 0;
    if (game.jumpT >= 0){
      // quick hop
      const s = Math.sin(Math.PI * game.jumpT);
      jumpOffset = -18 * s;
    }
    if (game.state === "winAnim"){
      const t = Math.min(900, game.winT);
      // 3 hops
      const s = Math.abs(Math.sin((Math.PI * 3) * (t/900)));
      jumpOffset = -22 * s;
    }

    // draw dancer
    ctx.save();
    ctx.translate(0, extraY);
    drawDancer(ctx, tilt, jumpOffset);
    ctx.restore();

    // name tag above head (always)
    drawNameTag(ctx, "agy96", dancer.x, dancer.y - 120);

    // cue bubble (only while playing)
    if (game.state === "playing") drawCueBubble();

    // confetti
    if (game.state === "winAnim" || game.state === "winModal"){
      drawConfetti(dt);
    }
  }

  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(33, ts - last);
    last = ts;

    update(dt);
    draw(dt);

    requestAnimationFrame(loop);
  }

  // ===== BUTTON HANDLERS =====
  function bindBtn(el, dir){
    el.addEventListener("pointerdown", (e)=>{
      e.preventDefault();
      handlePick(dir);
    }, {passive:false});
  }
  bindBtn(leftBtn, "left");
  bindBtn(rightBtn, "right");
  bindBtn(upBtn, "up");

  // ===== NEXT =====
  nextBtn.addEventListener("click", ()=>{
    ensureBgm();
    // after waterloo -> map with stadium prompt
    localStorage.setItem("mapPromptIndex", "3");
    location.href = "./map.html";
  });

  // ===== INIT =====
  resetRound();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
