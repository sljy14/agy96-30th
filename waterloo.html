<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Waterloo Ballet Studio</title>
  <style>
    :root{
      --cardBg1: rgba(20, 10, 26, 0.70);
      --cardBg2: rgba(10, 6, 18, 0.72);
      --border: rgba(255,255,255,0.12);
      --text: #f7f2ff;
      --muted: rgba(247,242,255,0.78);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 50% -10%, #2c1640, #06040a);
      color: var(--text);
    }
    .wrap{
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 10px 12px 14px;
    }
    .card{
      width:min(560px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, var(--cardBg1), var(--cardBg2));
      border: 1px solid var(--border);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }

    .header{
      padding: 16px 16px 10px;
      text-align:center;
    }
    h1{
      margin: 0 0 6px;
      font-size: 32px;
      line-height: 1.08;
      font-weight: 900;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .sub{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      padding: 0 14px 10px;
      flex-wrap: wrap;
    }
    .pill{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius: 999px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      letter-spacing: 0.2px;
      min-width: 0;
    }
    .pill small{ color: var(--muted); font-weight: 800; }

    .stage{ padding: 8px 12px 12px; }
    .frame{
      border-radius: 20px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      background: #f6ecff;
      touch-action: manipulation;
    }

    .hint{
      padding: 0 16px 14px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* Modal */
    .modal{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      z-index: 50;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width:min(520px, 94vw);
      border-radius: 22px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: 0 30px 90px rgba(0,0,0,0.55);
      padding: 18px 16px 16px;
      text-align:center;
    }
    .modalCard h2{
      margin: 6px 0 6px;
      font-size: 18px;
      font-weight: 950;
      letter-spacing: -0.01em;
    }
    .modalCard p{
      margin: 0 0 12px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .btn{
      appearance:none;
      border: 0;
      border-radius: 999px;
      padding: 14px 16px;
      font-weight: 950;
      letter-spacing: 0.2px;
      background: linear-gradient(180deg, rgba(255,170,220,0.22), rgba(255,170,220,0.12));
      color: var(--text);
      border: 1px solid rgba(255,170,220,0.28);
      cursor:pointer;
      width: 100%;
      max-width: 360px;
    }
    .btn:active{ transform: translateY(1px); }
  </style>
</head>

<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <h1>Welcome to the Waterloo ballet studio! ü©∞</h1>
      <p class="sub">Tap left or right to balance your piqu√© pose.</p>
    </div>

    <div class="hud">
      <div class="pill"><span>üéØ</span><span>Correct:&nbsp;<strong id="score">0</strong>&nbsp;<small>/ 10</small></span></div>
      <div class="pill"><span>‚è±Ô∏è</span><span>Time:&nbsp;<strong id="time">2.0</strong><small>s</small></span></div>
    </div>

    <div class="stage">
      <div class="frame">
        <canvas id="cv" width="390" height="560" aria-label="Waterloo ballet game"></canvas>
      </div>
    </div>

    <div class="hint">Each cue must be tapped within <strong>2.0s</strong>. Wrong side or no tap = fall + instant restart.</div>
  </div>
</div>

<div class="modal" id="winModal" role="dialog" aria-modal="true">
  <div class="modalCard">
    <h2>Congratulations! You balanced with grace under pressure. üôÜ‚Äç‚ôÄÔ∏è</h2>
    <p>Ready for your next mission?</p>
    <button id="nextBtn" class="btn">On to my next mission!</button>
  </div>
</div>

<!-- BGM (continues across pages; starts on first tap) -->
<audio id="bgm" src="arcade.mp3" preload="auto" loop></audio>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const scoreEl = document.getElementById("score");
  const timeEl  = document.getElementById("time");
  const winModal = document.getElementById("winModal");
  const nextBtn  = document.getElementById("nextBtn");

  // ===== BGM =====
  const bgm = document.getElementById("bgm");
  bgm.volume = 0.6;
  let bgmStarted = false;
  async function ensureBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    try{
      await bgm.play();
      localStorage.setItem("bgmPlaying","true");
    }catch(e){
      bgmStarted = false;
    }
  }
  if (localStorage.getItem("bgmPlaying")==="true"){
    ensureBgm();
  }

  // ===== GAME SETTINGS =====
  const GOAL = 10;
  const PER_CUE_MS = 2000;          // ‚úÖ 2.0s per cue
  const CUE_PAUSE_MS = 320;         // small breathing gap between cues

  // Cue direction: +1 = user must tap RIGHT, -1 = user must tap LEFT
  // Avatar tilts OPPOSITE of cue: tiltAngleTarget = -cueDir * tiltMax
  const tiltMax = 0.42;             // radians (~24¬∞) dramatic but readable
  const tiltDanger = 0.50;          // beyond this -> we consider "too far" visually (we still fail on timeout/wrong tap)

  // ===== UI HIT AREAS =====
  const btn = {
    w: 92, h: 92,
    gapToCenter: 128
  };

  // ===== STATE =====
  const S = {
    state: "playing",   // playing | falling | win
    score: 0,
    cueDir: 1,
    cueStart: 0,
    cueDeadline: 0,
    cuePulse: 0,        // 0..1 flash each cue
    tilt: 0,
    tiltTarget: 0,
    fallY: 0,
    fallVy: 0,
    confetti: []
  };

  function setHUD(){
    scoreEl.textContent = String(S.score);
    const msLeft = Math.max(0, S.cueDeadline - performance.now());
    timeEl.textContent = (msLeft/1000).toFixed(1);
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  function startCue(forceDir){
    S.cueDir = (typeof forceDir === "number") ? forceDir : (Math.random()<0.5 ? -1 : 1);
    S.cueStart = performance.now();
    S.cueDeadline = S.cueStart + PER_CUE_MS;
    S.cuePulse = 1; // ‚úÖ re-flash even if same direction
    S.tiltTarget = -S.cueDir * tiltMax;
  }

  function resetGame(){
    S.state = "playing";
    S.score = 0;
    S.tilt = 0;
    S.tiltTarget = 0;
    S.fallY = 0;
    S.fallVy = 0;
    S.confetti = [];
    startCue();
    setHUD();
  }

  function failDrop(){
    S.state = "falling";
    S.fallY = 0;
    S.fallVy = 10;
  }

  function win(){
    S.state = "win";
    // chaotic confetti overload üí•
    S.confetti = Array.from({length: 220}, () => ({
      x: rand(0, cv.width),
      y: rand(-cv.height, 0),
      vx: rand(-1.6, 1.6),
      vy: rand(2.4, 6.6),
      r: rand(2, 6),
      a: rand(0.35, 0.9)
    }));
    setTimeout(() => { winModal.classList.add("show"); }, 220);
  }

  // ===== INPUT =====
  function hitTestButton(px, py, side){
    const cx = cv.width/2;
    const cy = cv.height*0.56;

    const bx = (side === "left") ? (cx - btn.gapToCenter - btn.w/2) : (cx + btn.gapToCenter - btn.w/2);
    const by = cy - btn.h/2;

    return (px >= bx && px <= bx+btn.w && py >= by && py <= by+btn.h);
  }

  function onPress(dir){ // dir: -1 left, +1 right
    ensureBgm();
    if (S.state !== "playing") return;

    // must tap correct side before deadline
    if (dir !== S.cueDir){
      failDrop();
      return;
    }

    // correct
    S.score++;
    setHUD();

    // snap back upright before next cue
    S.tiltTarget = 0;

    if (S.score >= GOAL){
      win();
      return;
    }

    const nextDir = (Math.random()<0.5 ? -1 : 1);
    setTimeout(() => {
      // ensure we are still in playing (not failed during timeout)
      if (S.state === "playing"){
        startCue(nextDir);
      }
    }, CUE_PAUSE_MS);
  }

  cv.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    ensureBgm();

    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (cv.width / rect.width);
    const py = (e.clientY - rect.top)  * (cv.height / rect.height);

    if (hitTestButton(px, py, "left"))  onPress(-1);
    else if (hitTestButton(px, py, "right")) onPress(+1);
  }, {passive:false});

  // ===== DRAW HELPERS =====
  function roundRect(c, x, y, w, h, r){
    const rr = Math.min(r, w/2, h/2);
    c.beginPath();
    c.moveTo(x+rr, y);
    c.arcTo(x+w, y, x+w, y+h, rr);
    c.arcTo(x+w, y+h, x, y+h, rr);
    c.arcTo(x, y+h, x, y, rr);
    c.arcTo(x, y, x+w, y, rr);
    c.closePath();
  }

  function drawStudioBackground(){
    const W = cv.width, H = cv.height;

    // soft lavender + pink wall
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#f6eaff");
    g.addColorStop(0.55, "#f8e7f0");
    g.addColorStop(1, "#f2d7ff");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // mirror wall panels
    ctx.fillStyle = "rgba(255,255,255,0.50)";
    ctx.globalAlpha = 0.55;
    for (let i=0;i<4;i++){
      const x = 36 + i*(W-72)/4;
      ctx.fillRect(x, 120, (W-72)/4 - 8, 250);
      ctx.fillStyle = "rgba(220,210,235,0.40)";
      ctx.fillRect(x, 120, 2, 250);
      ctx.fillStyle = "rgba(255,255,255,0.50)";
    }
    ctx.globalAlpha = 1;

    // overhead lights (subtle)
    for (let i=0;i<4;i++){
      const lx = 70 + i*(W-140)/3;
      ctx.fillStyle = "rgba(255,255,255,0.70)";
      roundRect(ctx, lx-26, 72, 52, 12, 6);
      ctx.fill();
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      roundRect(ctx, lx-30, 86, 60, 10, 6);
      ctx.fill();
    }

    // ballet barre
    const barY = 360;
    ctx.fillStyle = "rgba(150, 100, 95, 0.65)";
    ctx.fillRect(40, barY, W-80, 10);
    ctx.fillStyle = "rgba(110, 80, 78, 0.35)";
    ctx.fillRect(40, barY+8, W-80, 3);

    // barre posts
    ctx.fillStyle = "rgba(120, 95, 105, 0.35)";
    for (let i=0;i<4;i++){
      const px = 70 + i*(W-140)/3;
      ctx.fillRect(px, barY, 6, 80);
    }

    // floor
    const floorTop = 410;
    const gf = ctx.createLinearGradient(0,floorTop,0,H);
    gf.addColorStop(0, "#f1cfa8");
    gf.addColorStop(1, "#d9a86f");
    ctx.fillStyle = gf;
    ctx.fillRect(0, floorTop, W, H-floorTop);

    // floor planks
    ctx.fillStyle = "rgba(0,0,0,0.06)";
    for (let x=18; x<W; x+=26){
      ctx.fillRect(x, floorTop, 2, H-floorTop);
    }

    // spotlight cone
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(W*0.68, 0);
    ctx.lineTo(W*0.96, 0);
    ctx.lineTo(W*0.74, floorTop+80);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawArrowButton(side){
    const cx = cv.width/2;
    const cy = cv.height*0.56;

    const x = (side==="left") ? (cx - btn.gapToCenter - btn.w/2) : (cx + btn.gapToCenter - btn.w/2);
    const y = cy - btn.h/2;

    // frosted button
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(255,255,255,0.40)";
    roundRect(ctx, x, y, btn.w, btn.h, 18);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.40)";
    ctx.lineWidth = 2;
    roundRect(ctx, x, y, btn.w, btn.h, 18);
    ctx.stroke();

    // arrow
    ctx.fillStyle = "rgba(30,25,40,0.75)";
    ctx.font = "40px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(side==="left" ? "‚Äπ" : "‚Ä∫", x + btn.w/2, y + btn.h/2 + 1);
    ctx.restore();
  }

  // glasses helper (same vibe as your other scenes)
  function drawGlasses(c, leftX, gy, lensW, lensH, thick, gap, armLen){
    c.fillStyle = "#000";
    c.fillRect(leftX, gy, lensW, thick);
    c.fillRect(leftX, gy + lensH - thick, lensW, thick);
    c.fillRect(leftX, gy, thick, lensH);
    c.fillRect(leftX + lensW - thick, gy, thick, lensH);

    const rightX = leftX + lensW + gap;
    c.fillRect(rightX, gy, lensW, thick);
    c.fillRect(rightX, gy + lensH - thick, lensW, thick);
    c.fillRect(rightX, gy, thick, lensH);
    c.fillRect(rightX + lensW - thick, gy, thick, lensH);

    c.fillRect(leftX + lensW, gy + Math.floor(lensH/2) - 1, gap, 2);

    c.fillRect(leftX - armLen, gy + 2, armLen, 2);
    c.fillRect(rightX + lensW, gy + 2, armLen, 2);
  }

  function drawAgyBallet(x, y, tiltRad){
    // y is "feet baseline" around floor line area
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(tiltRad);

    // hair
    ctx.fillStyle="#000";
    ctx.fillRect(-18, -92, 36, 60);

    // face
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(-12, -76, 24, 28);

    // glasses (clean + aligned)
    const gy = -70;
    const lensW = 11, lensH = 9;
    const thick = 2, gap = 5, armLen = 4;
    const leftX = -14;
    drawGlasses(ctx, leftX, gy, lensW, lensH, thick, gap, armLen);

    // sleeveless top (light blue)
    ctx.fillStyle="#9bd1ff";
    ctx.fillRect(-16, -48, 32, 24);

    // tiny arm nubs
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(-20, -46, 4, 16);
    ctx.fillRect(16, -46, 4, 16);

    // tutu (pink) - simple block like your style
    ctx.fillStyle="#ff8ccf";
    ctx.fillRect(-24, -26, 48, 14);

    // LEGS (your requested geometry)
    // Standing LEFT leg (vertical)
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(-6, -12, 10, 54);

    // Pointe shoe (standing)
    ctx.fillStyle="#fff";
    ctx.fillRect(-8, 40, 16, 6);

    // Bent RIGHT leg: thigh out -> shin back toward standing leg
    // thigh (horizontal out to right)
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(6, 8, 28, 8);

    // shin: diagonal back inward (step-diagonal)
    ctx.fillRect(30, 14, 8, 8);
    ctx.fillRect(24, 20, 8, 8);
    ctx.fillRect(18, 26, 8, 8);

    // toe near standing leg
    ctx.fillStyle="#fff";
    ctx.fillRect(14, 32, 12, 6);

    ctx.restore();
  }

  function drawCueBubble(){
    const cx = cv.width/2;
    const cy = cv.height*0.30;

    // pulse: starts at 1 and eases down
    const pulse = Math.max(0, Math.min(1, S.cuePulse));
    const alpha = 0.55 + 0.35*pulse;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "rgba(255,255,255,0.50)";
    roundRect(ctx, cx-76, cy-26, 152, 52, 18);
    ctx.fill();

    ctx.globalAlpha = 0.35 + 0.35*pulse;
    ctx.strokeStyle = "rgba(255, 120, 190, 0.55)";
    ctx.lineWidth = 3;
    roundRect(ctx, cx-76, cy-26, 152, 52, 18);
    ctx.stroke();

    // emoji cue: üëà or üëâ (above head)
    ctx.globalAlpha = 0.95;
    ctx.font = "26px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(30,25,40,0.85)";
    ctx.fillText(S.cueDir === 1 ? "üëâ" : "üëà", cx, cy+1);
    ctx.restore();
  }

  function drawShadow(){
    const cx = cv.width/2;
    const sy = cv.height*0.78 + 16;
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(0,0,0,0.75)";
    ctx.beginPath();
    ctx.ellipse(cx, sy, 60, 16, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawProgressBar(){
    const W = cv.width;
    const x = 32, y = cv.height - 54;
    const w = W - 64, h = 10;

    // track
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(0,0,0,0.60)";
    roundRect(ctx, x, y, w, h, 999);
    ctx.fill();
    ctx.restore();

    // fill
    const p = S.score / GOAL;
    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "rgba(120, 255, 190, 0.75)";
    roundRect(ctx, x, y, Math.max(10, w*p), h, 999);
    ctx.fill();
    ctx.restore();

    // dot
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#ff74c7";
    ctx.beginPath();
    ctx.arc(x + w*p, y + h/2, 8, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  function drawConfetti(dt){
    if (!S.confetti.length) return;
    for (const p of S.confetti){
      p.x += p.vx * dt * 0.7;
      p.y += p.vy * dt * 0.7;
      if (p.y > cv.height + 20){
        p.y = rand(-cv.height, -20);
        p.x = rand(0, cv.width);
      }
      ctx.fillStyle = `rgba(255, 140, 210, ${p.a})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ===== UPDATE LOOP =====
  let last = 0;
  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(33, ts - last);
    last = ts;

    const now = performance.now();

    if (S.state === "playing"){
      // timeout fail
      if (now > S.cueDeadline){
        failDrop();
      }

      // cue pulse decay
      S.cuePulse *= 0.92;

      // tilt ease
      S.tilt += (S.tiltTarget - S.tilt) * 0.12;

      setHUD();
    } else if (S.state === "falling"){
      // make her tilt a bit more + drop down
      S.tilt += (Math.sign(S.tiltTarget || 1) * (tiltDanger+0.35) - S.tilt) * 0.10;
      S.fallVy += 1.25;
      S.fallY  += S.fallVy;

      if (S.fallY > 320){
        // instant restart
        resetGame();
      }
    } else if (S.state === "win"){
      // keep confetti moving
      setHUD();
    }

    // ===== DRAW =====
    ctx.clearRect(0,0,cv.width,cv.height);
    drawStudioBackground();

    // cue + buttons (only if not win modal)
    drawCueBubble();
    drawArrowButton("left");
    drawArrowButton("right");

    // dancer
    const ax = cv.width/2;
    const ay = cv.height*0.78; // baseline near floor
    drawShadow();

    const tilt = S.tilt;
    const dropY = (S.state === "falling") ? S.fallY : 0;
    drawAgyBallet(ax, ay + dropY, tilt);

    // progress
    drawProgressBar();

    // win confetti
    drawConfetti(dt);

    requestAnimationFrame(loop);
  }

  // ===== WIN ACTION =====
  nextBtn.addEventListener("click", () => {
    // go back to map with STADIUM prompt
    localStorage.setItem("mapPromptIndex", "3"); // prompts[3] = stadium in your map file
    localStorage.setItem("bgmPlaying","true");
    location.href = "./map.html"; // <-- change if your map file is named differently
  });

  // ===== INIT =====
  resetGame();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
