<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Waterloo Ballet Studio</title>

  <style>
    :root{
      --cardBg1: rgba(34, 10, 56, 0.70);
      --cardBg2: rgba(16, 6, 26, 0.70);
      --border: rgba(255,255,255,0.12);
      --text: #f6f2ff;
      --muted: rgba(246,242,255,0.76);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 50% -10%, rgba(255,160,220,0.18), transparent 60%),
        radial-gradient(900px 520px at 50% 120%, rgba(130,220,255,0.14), transparent 60%),
        linear-gradient(160deg,#12051d,#060616);
      min-height:100svh;
      display:flex;
      justify-content:center;
      padding: 10px 12px 14px;
    }

    .card{
      width:min(560px, 100%);
      border-radius: 24px;
      background: linear-gradient(180deg, var(--cardBg1), var(--cardBg2));
      border: 1px solid var(--border);
      box-shadow: 0 30px 80px rgba(0,0,0,0.55);
      overflow:hidden;
    }

    .header{
      padding: 16px 16px 8px;
      text-align:center;
    }
    h1{
      margin: 0 0 6px;
      font-size: 32px;
      line-height: 1.08;
      font-weight: 900;
      letter-spacing: -0.02em;
      text-shadow: 0 2px 10px rgba(0,0,0,0.35);
    }
    .sub{
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    .hud{
      display:flex;
      gap: 10px;
      justify-content: space-between;
      padding: 0 14px 10px;
      flex-wrap: wrap;
    }
    .pill{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      border-radius: 999px;
      padding: 10px 10px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      font-weight: 900;
      letter-spacing: 0.2px;
      min-width: 0;
    }
    .pill small{
      color: var(--muted);
      font-weight: 800;
    }

    .stage{ padding: 8px 12px 10px; }
    .frame{
      border-radius: 20px;
      background: rgba(0,0,0,0.16);
      border: 1px solid rgba(255,255,255,0.10);
      padding: 10px;
      position: relative;
      overflow: hidden;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius: 16px;
      background: #f2eaff;
      touch-action: manipulation;
    }

    .controls{
      position:absolute;
      inset: 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      pointer-events:none;
    }
    .btnArrow{
      pointer-events:auto;
      width: 78px;
      height: 78px;
      border-radius: 18px;
      border: 1px solid rgba(0,0,0,0.10);
      background: rgba(255,255,255,0.45);
      box-shadow: 0 10px 22px rgba(0,0,0,0.12);
      display:grid;
      place-items:center;
      user-select:none;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: transform 90ms ease;
    }
    .btnArrow:active{ transform: scale(0.96); }

    .btnArrow svg{
      width: 38px;
      height: 38px;
      opacity: 0.9;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.18));
    }

    .hint{
      padding: 0 16px 14px;
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    /* popup */
    .overlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,0.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 10;
    }
    .overlay.show{ display:flex; }
    .modal{
      width: min(420px, 96vw);
      background: rgba(18, 8, 28, 0.82);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 30px 90px rgba(0,0,0,0.55);
      padding: 16px 14px 14px;
      text-align:center;
    }
    .modalTitle{
      font-size: 18px;
      font-weight: 900;
      margin: 0 0 10px;
      letter-spacing: -0.01em;
    }
    .modalBtn{
      width: 100%;
      border: 0;
      border-radius: 999px;
      padding: 14px 16px;
      font-weight: 900;
      letter-spacing: 0.2px;
      background: linear-gradient(180deg, rgba(159,240,200,0.22), rgba(159,240,200,0.12));
      border: 1px solid rgba(159,240,200,0.28);
      color: var(--text);
      cursor:pointer;
    }
    .modalBtn:active{ transform: translateY(1px); }
  </style>
</head>

<body>
  <div class="card">
    <div class="header">
      <h1>Welcome to the Waterloo ballet studio! ü©∞</h1>
      <p class="sub">Tap left or right to balance your piqu√© pose.</p>
    </div>

    <div class="hud">
      <div class="pill"><span>‚è±Ô∏è</span><span><strong id="timeLeft">10.0</strong>&nbsp;<small>s left</small></span></div>
      <div class="pill"><span>‚öñÔ∏è</span><span>Balance:&nbsp;<strong id="balanceState">steady</strong></span></div>
    </div>

    <div class="stage">
      <div class="frame">
        <canvas id="game" width="390" height="520" aria-label="Waterloo balance game"></canvas>

        <div class="controls">
          <div id="leftBtn" class="btnArrow" role="button" aria-label="Left">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M14.5 5.5L8 12l6.5 6.5" stroke="rgba(30,35,55,0.95)" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
          <div id="rightBtn" class="btnArrow" role="button" aria-label="Right">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M9.5 5.5L16 12l-6.5 6.5" stroke="rgba(30,35,55,0.95)" stroke-width="3.2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </div>
        </div>
      </div>
    </div>

    <div class="hint">Survive 10 seconds. Tap the correct side when the cue appears above her head.</div>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="modal">
      <div class="modalTitle">Congratulations! You balanced with grace under pressure. üôÜ‚Äç‚ôÄÔ∏è</div>
      <button id="nextBtn" class="modalBtn">On to my next mission!</button>
    </div>
  </div>

  <audio id="bgm" src="arcade.mp3" preload="auto" loop></audio>

<script>
(() => {
  // ===== DOM =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;

  const leftBtn = document.getElementById("leftBtn");
  const rightBtn = document.getElementById("rightBtn");

  const timeLeftEl = document.getElementById("timeLeft");
  const balanceStateEl = document.getElementById("balanceState");

  const overlay = document.getElementById("overlay");
  const nextBtn = document.getElementById("nextBtn");

  const bgm = document.getElementById("bgm");
  bgm.volume = 0.6;

  // ===== BGM =====
  let bgmStarted = false;
  async function ensureBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    try{
      await bgm.play();
      localStorage.setItem("bgmPlaying","true");
    }catch(e){
      bgmStarted = false;
    }
  }
  if (localStorage.getItem("bgmPlaying")==="true"){
    bgm.play().catch(()=>{});
  }

  // ===== Utilities =====
  const rand = (a,b)=>a + Math.random()*(b-a);
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // ===== Game state =====
  const GAME = {
    totalMs: 10000,
    elapsedMs: 0,
    running: true,
    state: "playing", // playing | dropping | win
    lean: 0,
    leanVel: 0,
    shake: 0,

    // cue system
    cueVisible: true,
    cueFlashMs: 360,   // üëàüëâ appears as a "flash", not permanently
    cueOffMs: 170,     // small off gap before the next flash
    cueTimer: 0,       // counts within flash/off cycle
    cueMode: "on",     // on | off

    // challenge direction (what she is currently leaning toward)
    // We purposely allow repeats, but we still "flash" again each time.
    challengeDir: -1,  // -1 means she leans left, +1 leans right

    // confetti
    confetti: []
  };

  // ===== Cue rules =====
  // IMPORTANT:
  // If she leans LEFT, cue shows RIGHT üëâ and user must tap RIGHT
  // If she leans RIGHT, cue shows LEFT üëà and user must tap LEFT
  function requiredTap(){
    return (GAME.challengeDir < 0) ? 1 : -1; // lean left -> tap right
  }
  function cueEmoji(){
    return (GAME.challengeDir < 0) ? "üëâ" : "üëà";
  }

  // Randomize challenge direction with "no more than 2 in a row"
  let streak = 0;
  let lastChallenge = 0;
  function pickNextChallenge(){
    let dir = Math.random() < 0.5 ? -1 : 1;
    if (dir === lastChallenge) streak++; else streak = 1;
    if (streak >= 3){
      dir *= -1;
      streak = 1;
    }
    lastChallenge = dir;
    GAME.challengeDir = dir;

    // restart the flash cycle so even repeats "re-appear"
    GAME.cueMode = "on";
    GAME.cueTimer = 0;
    GAME.cueVisible = true;
  }

  // ===== Balance label =====
  function setBalanceLabel(){
    const a = Math.abs(GAME.lean);
    let label = "steady";
    if (a > 0.70) label = "danger";
    else if (a > 0.34) label = "wobble";
    balanceStateEl.textContent = label;
  }

  // ===== Reset / win / drop =====
  function resetGame(){
    GAME.elapsedMs = 0;
    GAME.running = true;
    GAME.state = "playing";
    GAME.lean = 0;
    GAME.leanVel = 0;
    GAME.shake = 0;

    GAME.confetti = [];
    overlay.classList.remove("show");
    overlay.setAttribute("aria-hidden","true");

    streak = 0;
    lastChallenge = 0;

    pickNextChallenge();

    timeLeftEl.textContent = "10.0";
    setBalanceLabel();
  }

  function triggerDrop(){
    if (GAME.state !== "playing") return;
    GAME.state = "dropping";
    GAME.running = false;
    GAME.shake = 10;
    // quick restart
    setTimeout(resetGame, 650);
  }

  function spawnConfetti(){
    const n = 240;
    for (let i=0;i<n;i++){
      GAME.confetti.push({
        x: canvas.width/2 + rand(-30, 30),
        y: canvas.height*0.42 + rand(-20, 20),
        vx: rand(-2.6, 2.6),
        vy: rand(-4.4, -1.2),
        g: rand(0.06, 0.12),
        r: rand(2.2, 5.0),
        a: rand(0.65, 1.0),
        spin: rand(-0.25, 0.25),
        ang: rand(0, Math.PI*2)
      });
    }
  }

  function win(){
    GAME.state = "win";
    GAME.running = false;
    spawnConfetti();
    overlay.classList.add("show");
    overlay.setAttribute("aria-hidden","false");
  }

  // ===== Input =====
  function handleTap(dir){
    ensureBgm();
    if (!GAME.running || GAME.state !== "playing") return;

    const needed = requiredTap();

    if (dir === needed){
      // Correct: push back toward center and then pick next challenge
      GAME.leanVel += (-GAME.lean) * 0.09;
      GAME.leanVel += dir * 0.05;
      GAME.shake = 4;

      pickNextChallenge();
    } else {
      triggerDrop();
    }
  }

  leftBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleTap(-1); }, {passive:false});
  rightBtn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); handleTap( 1); }, {passive:false});

  canvas.addEventListener("pointerdown", ()=>ensureBgm(), {passive:true});

  // ===== Background: ballet studio =====
  function drawStudio(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, "#f7f0ff");
    g.addColorStop(0.55, "#f2e9ff");
    g.addColorStop(1, "#f6d8f0");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // ceiling lights
    ctx.globalAlpha = 0.8;
    for (let i=0;i<4;i++){
      const x = 60 + i*85;
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      roundedRect(x, 44, 56, 14, 7);
      ctx.fill();
      ctx.fillStyle = "rgba(0,0,0,0.06)";
      roundedRect(x, 58, 56, 3, 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // mirror
    ctx.fillStyle = "rgba(255,255,255,0.60)";
    roundedRect(22, 90, canvas.width-44, 210, 18);
    ctx.fill();

    ctx.strokeStyle = "rgba(150,120,170,0.18)";
    ctx.lineWidth = 2;
    for (let i=1;i<4;i++){
      const x = 22 + (canvas.width-44) * (i/4);
      ctx.beginPath();
      ctx.moveTo(x, 96);
      ctx.lineTo(x, 290);
      ctx.stroke();
    }

    // barre
    ctx.fillStyle = "rgba(180,140,120,0.85)";
    roundedRect(18, 320, canvas.width-36, 14, 7);
    ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,0.07)";
    roundedRect(18, 331, canvas.width-36, 4, 2);
    ctx.fill();

    ctx.fillStyle = "rgba(110,100,125,0.35)";
    for (let i=0;i<4;i++){
      const x = 70 + i*85;
      ctx.fillRect(x, 332, 6, 54);
    }

    // floor
    const f = ctx.createLinearGradient(0, 360, 0, canvas.height);
    f.addColorStop(0, "#e7b881");
    f.addColorStop(1, "#d8a76b");
    ctx.fillStyle = f;
    ctx.fillRect(0, 360, canvas.width, canvas.height-360);

    // boards
    ctx.strokeStyle = "rgba(120,80,50,0.10)";
    ctx.lineWidth = 2;
    for (let x=20; x<canvas.width; x+=28){
      ctx.beginPath();
      ctx.moveTo(x, 360);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }

    // spotlight
    ctx.globalAlpha = 0.55;
    const cone = ctx.createRadialGradient(canvas.width/2, 250, 10, canvas.width/2, 360, 240);
    cone.addColorStop(0, "rgba(255,255,255,0.95)");
    cone.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = cone;
    ctx.beginPath();
    ctx.ellipse(canvas.width/2, 350, 160, 220, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ===== Cue above head (emoji flash) =====
  function drawCue(){
    if (!GAME.cueVisible) return;

    const cx = canvas.width/2;
    const cy = 190;

    ctx.globalAlpha = 0.88;
    ctx.fillStyle = "rgba(255,255,255,0.45)";
    roundedRect(cx-44, cy-34, 88, 64, 18);
    ctx.fill();
    ctx.globalAlpha = 1;

    const emoji = cueEmoji();
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "rgba(55, 40, 90, 0.95)";
    ctx.fillText(emoji, cx, cy);

    ctx.strokeStyle = "rgba(255, 160, 220, 0.65)";
    ctx.lineWidth = 2;
    ctx.strokeRect(cx-34, cy-24, 68, 44);
  }

  // ===== Avatar drawing =====
  function drawGlasses(localCtx, leftX, gy, lensW, lensH, thick, gap, armLen){
    localCtx.fillStyle = "#000";
    localCtx.fillRect(leftX, gy, lensW, thick);
    localCtx.fillRect(leftX, gy + lensH - thick, lensW, thick);
    localCtx.fillRect(leftX, gy, thick, lensH);
    localCtx.fillRect(leftX + lensW - thick, gy, thick, lensH);

    const rightX = leftX + lensW + gap;
    localCtx.fillRect(rightX, gy, lensW, thick);
    localCtx.fillRect(rightX, gy + lensH - thick, lensW, thick);
    localCtx.fillRect(rightX, gy, thick, lensH);
    localCtx.fillRect(rightX + lensW - thick, gy, thick, lensH);

    localCtx.fillRect(leftX + lensW, gy + Math.floor(lensH/2) - 1, gap, 2);
    localCtx.fillRect(leftX - armLen, gy + 2, armLen, 2);
    localCtx.fillRect(rightX + lensW, gy + 2, armLen, 2);
  }

  function drawAgyBallet(x, y, lean){
    // y is feet baseline
    const pivotX = x;
    const pivotY = y - 26;

    ctx.save();
    ctx.translate(pivotX, pivotY);
    ctx.rotate(lean * 0.34); // ‚úÖ slower / less dramatic tilt
    ctx.translate(-pivotX, -pivotY);

    // hair (same style)
    ctx.fillStyle="#000";
    ctx.fillRect(x-18, y-92, 36, 60);

    // face
    ctx.fillStyle="#f1c7a6";
    ctx.fillRect(x-12, y-76, 24, 28);

    // glasses
    const gy = y - 70;
    const lensW = 11, lensH = 9;
    const thick = 2, gap = 5, armLen = 4;
    const leftX = x - 14;
    drawGlasses(ctx, leftX, gy, lensW, lensH, thick, gap, armLen);

    // top (light blue, sleeveless)
    ctx.fillStyle="#8fd1ff";
    ctx.fillRect(x-16, y-48, 32, 22);

    // arms (kept same as your ‚Äúgood‚Äù version)
    ctx.strokeStyle = "#f1c7a6";
    ctx.lineWidth = 6;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(x-18, y-44);
    ctx.quadraticCurveTo(x-36, y-58, x-22, y-66);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x+18, y-44);
    ctx.quadraticCurveTo(x+36, y-58, x+22, y-66);
    ctx.stroke();

    // tutu
    ctx.fillStyle="#ff9cc7";
    ctx.fillRect(x-22, y-28, 44, 10);
    ctx.fillStyle="#ff84bd";
    ctx.fillRect(x-26, y-18, 52, 16);

    // ‚úÖ legs: "I \ / I" silhouette (as requested)
    ctx.fillStyle="#f1c7a6";

    // center straight leg (I)
    ctx.fillRect(x-3, y-2, 6, 34);

    // left diagonal (\)
    ctx.save();
    ctx.translate(x-4, y+8);
    ctx.rotate(-0.38);
    ctx.fillRect(-3, 0, 6, 26);
    ctx.restore();

    // right diagonal (/)
    ctx.save();
    ctx.translate(x+10, y+8);
    ctx.rotate(0.38);
    ctx.fillRect(-3, 0, 6, 26);
    ctx.restore();

    // pointe shoes aligned to legs
    ctx.fillStyle="#ffe6f1";
    ctx.fillRect(x-10, y+30, 20, 6); // center shoe

    ctx.save();
    ctx.translate(x-14, y+30);
    ctx.rotate(-0.18);
    ctx.fillRect(-6, 0, 14, 6);
    ctx.restore();

    ctx.save();
    ctx.translate(x+18, y+30);
    ctx.rotate(0.18);
    ctx.fillRect(-8, 0, 14, 6);
    ctx.restore();

    ctx.restore();

    // shadow
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(x, y+34, 34, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ===== Confetti =====
  function updateConfetti(dt){
    for (const p of GAME.confetti){
      p.x += p.vx * dt * 0.9;
      p.y += p.vy * dt * 0.9;
      p.vy += p.g * dt;
      p.ang += p.spin * dt;
      p.a = Math.max(0, p.a - 0.0009 * dt);
    }
    GAME.confetti = GAME.confetti.filter(p => p.a > 0.02 && p.y < canvas.height + 80);
  }

  function drawConfetti(){
    for (const p of GAME.confetti){
      ctx.save();
      ctx.globalAlpha = p.a;
      ctx.translate(p.x, p.y);
      ctx.rotate(p.ang);
      const hue = (p.x * 2 + p.y) % 360;
      ctx.fillStyle = `hsla(${hue}, 92%, 68%, ${p.a})`;
      ctx.fillRect(-p.r, -p.r, p.r*2, p.r*2);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  }

  // ===== Update / draw =====
  function update(dt){
    if (GAME.state !== "playing") return;

    GAME.elapsedMs += dt;

    // countdown
    const left = Math.max(0, (GAME.totalMs - GAME.elapsedMs) / 1000);
    timeLeftEl.textContent = left.toFixed(1);

    if (GAME.elapsedMs >= GAME.totalMs){
      win();
      return;
    }

    // ‚úÖ slower drift outward (playable)
    const t = clamp(GAME.elapsedMs / GAME.totalMs, 0, 1);
    const driftStrength = 0.0009 + 0.00055 * t; // slower than before
    GAME.leanVel += GAME.challengeDir * driftStrength * dt;

    // damping
    GAME.leanVel *= 0.972;
    GAME.lean += GAME.leanVel;

    // clamp
    GAME.lean = clamp(GAME.lean, -1.2, 1.2);

    // cue flash cycle (so repeats "re-appear")
    GAME.cueTimer += dt;
    if (GAME.cueMode === "on" && GAME.cueTimer > GAME.cueFlashMs){
      GAME.cueMode = "off";
      GAME.cueTimer = 0;
      GAME.cueVisible = false;
    } else if (GAME.cueMode === "off" && GAME.cueTimer > GAME.cueOffMs){
      GAME.cueMode = "on";
      GAME.cueTimer = 0;
      GAME.cueVisible = true;
    }

    setBalanceLabel();
  }

  function draw(){
    const shakeX = GAME.shake > 0 ? (Math.random()*4 - 2) : 0;
    const shakeY = GAME.shake > 0 ? (Math.random()*4 - 2) : 0;
    if (GAME.shake > 0) GAME.shake -= 1;

    ctx.save();
    ctx.translate(shakeX, shakeY);

    drawStudio();
    drawCue();

    // dancer
    const x = canvas.width/2;
    const y = 390;

    // visual lean (cap)
    const leanVisual = clamp(GAME.lean, -1, 1);
    drawAgyBallet(x, y, leanVisual);

    // balance meter
    const barY = canvas.height - 58;
    const barX = 28;
    const barW = canvas.width - 56;
    const barH = 10;

    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    roundedRect(barX, barY, barW, barH, 999);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "rgba(120,255,190,0.55)";
    roundedRect(barX + barW*0.35, barY, barW*0.30, barH, 999);
    ctx.fill();
    ctx.globalAlpha = 1;

    const p = (leanVisual + 1) / 2;
    const dotX = barX + p * barW;
    ctx.fillStyle = "rgba(255,120,190,0.95)";
    ctx.beginPath();
    ctx.arc(dotX, barY + barH/2, 7.5, 0, Math.PI*2);
    ctx.fill();

    if (GAME.confetti.length) drawConfetti();

    ctx.restore();
  }

  // ===== RAF =====
  let last = 0;
  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(33, ts - last);
    last = ts;

    if (GAME.running) update(dt);
    if (GAME.confetti.length) updateConfetti(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ===== Win button -> map with stadium prompt =====
  nextBtn.addEventListener("click", () => {
    localStorage.setItem("mapPromptIndex", "3"); // stadium question
    localStorage.setItem("returnFrom", "waterloo");
    location.href = "./map.html";
  });

  // ===== init =====
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
